-- Databricks notebook source
-- MAGIC %md
-- MAGIC ### Create `locations_mapped` and `work_id_map` tables IF THEY DO NOT EXIST
-- MAGIC No table re-creation and full idempotency are new features.

-- COMMAND ----------

CREATE TABLE IF NOT EXISTS identifier('openalex' || :env_suffix || '.works.locations_mapped') (
  work_id BIGINT,
  work_id_source STRING,
  merge_key STRUCT<doi: STRING, pmid: STRING, arxiv: STRING, title_author: STRING>,
  key_lineage STRING,
  provenance STRING,
  native_id STRING,
  --true_native_id STRING,
  native_id_namespace STRING,
  title STRING,
  normalized_title STRING,
  authors ARRAY<STRUCT<given: STRING, family: STRING, name: STRING, orcid: STRING, affiliations: ARRAY<STRUCT<name: STRING, department: STRING, ror_id: STRING>>, is_corresponding: BOOLEAN, author_key: STRING>>,
  ids ARRAY<STRUCT<id: STRING, namespace: STRING, relationship: STRING>>,
  type STRING,
  version STRING,
  license STRING,
  language STRING,
  published_date DATE,
  created_date DATE,
  updated_date DATE,
  issue STRING,
  volume STRING,
  first_page STRING,
  last_page STRING,
  is_retracted BOOLEAN,
  abstract STRING,
  source_name STRING,
  publisher STRING,
  funders ARRAY<STRUCT<doi: STRING, ror: STRING, name: STRING, awards: ARRAY<STRING>>>,
  references ARRAY<STRUCT<doi: STRING, pmid: STRING, arxiv: STRING, title: STRING, authors: STRING, year: STRING, raw: STRING>>,
  urls ARRAY<STRUCT<url: STRING, content_type: STRING>>,
  pdf_url STRING,
  landing_page_url STRING,
  pdf_s3_id STRING,
  grobid_s3_id STRING,
  mesh STRING,
  is_oa BOOLEAN,
  is_oa_source BOOLEAN,
  referenced_works_count INT,
  referenced_works ARRAY<BIGINT>,
  abstract_inverted_index STRING,
  authors_exist BOOLEAN,
  affiliations_exist BOOLEAN,
  is_corresponding_exists BOOLEAN,
  best_doi STRING,
  source_id BIGINT,
  openalex_created_dt DATE,
  openalex_updated_dt TIMESTAMP)
USING delta
CLUSTER BY (merge_key.doi, merge_key.pmid, merge_key.arxiv, merge_key.title_author)
TBLPROPERTIES (
  'delta.checkpoint.writeStatsAsJson' = 'false',
  'delta.checkpoint.writeStatsAsStruct' = 'true',
  'delta.enableDeletionVectors' = 'true',
  'delta.feature.deletionVectors' = 'supported',
  'delta.feature.rowTracking' = 'supported',
  'delta.feature.v2Checkpoint' = 'supported');

CREATE TABLE IF NOT EXISTS identifier('openalex' || :env_suffix || '.works.work_id_map') (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 6600000001 INCREMENT BY 1),
  paper_id STRING,
  doi STRING,
  pmid STRING,
  arxiv STRING,
  title_author STRING,
  work_id_source STRING,
  openalex_created_dt DATE,
  openalex_updated_dt TIMESTAMP
)
CLUSTER BY (doi, pmid, arxiv, title_author)
TBLPROPERTIES (
  'delta.deletedFileRetentionDuration' = '60 days', -- default is 7
  'delta.logRetentionDuration' = '60 days',         -- default is 30  
  'delta.checkpoint.writeStatsAsJson' = 'false',
  'delta.checkpoint.writeStatsAsStruct' = 'true',
  'delta.enableDeletionVectors' = 'true',
  'delta.feature.deletionVectors' = 'supported',
  'delta.feature.rowTracking' = 'supported',
  'delta.feature.v2Checkpoint' = 'supported');  

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### Merge deduplicated records from `locations_w_sources` into `locations_mapped`
-- MAGIC Merge deduplicated records from `locations_w_sources` into `locations_mapped`, inserting rows with `work_id = NULL` and updating others.

-- COMMAND ----------

-- MAGIC %md
-- MAGIC #### First merge update by DOI to avoid overly wide merge on overall merge key that produces too many insertions

-- COMMAND ----------

WITH distinct_works AS (
    SELECT  *,
            ROW_NUMBER() OVER (
               PARTITION BY merge_key,
                            native_id,
                            native_id_namespace,
                            provenance
               ORDER BY updated_date DESC) AS rwcnt
    FROM identifier('openalex' || :env_suffix || '.works.locations_w_sources')
    QUALIFY rwcnt = 1
)
/* ==========================================================
   PASS A â€“ DOI-only UPDATE (no inserts)
   ========================================================== */
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped')    AS target
USING distinct_works                                                             AS source
ON target.merge_key.doi = source.merge_key.doi
    AND (
      target.provenance = source.provenance OR 
      (target.provenance IN ('repo', 'repo_backfill') AND source.provenance IN ('repo', 'repo_backfill'))
    ) 
    -- needed because repo and repo_backfill records with the same ID are switching back and forth
    -- maybe in the union step
    AND target.native_id IS NOT DISTINCT FROM source.native_id
    AND target.native_id_namespace IS NOT DISTINCT FROM source.native_id_namespace
    AND target.merge_key.doi IS NOT NULL
WHEN MATCHED
AND (
      target.provenance IS DISTINCT FROM source.provenance OR
      target.native_id IS DISTINCT FROM source.native_id OR
      target.native_id_namespace IS DISTINCT FROM source.native_id_namespace OR
      target.title IS DISTINCT FROM source.title OR
      target.normalized_title IS DISTINCT FROM source.normalized_title OR
      target.type IS DISTINCT FROM source.type OR
      target.version IS DISTINCT FROM source.version OR
      target.license IS DISTINCT FROM source.license OR
      target.language IS DISTINCT FROM source.language OR
      target.published_date IS DISTINCT FROM source.published_date OR
      target.created_date IS DISTINCT FROM source.created_date OR
      target.issue IS DISTINCT FROM source.issue OR
      target.volume IS DISTINCT FROM source.volume OR
      target.first_page IS DISTINCT FROM source.first_page OR
      target.last_page IS DISTINCT FROM source.last_page OR
      target.is_retracted IS DISTINCT FROM source.is_retracted OR
      target.abstract IS DISTINCT FROM source.abstract OR
      target.source_name IS DISTINCT FROM source.source_name OR
      target.publisher IS DISTINCT FROM source.publisher OR
      target.pdf_url IS DISTINCT FROM source.pdf_url OR
      target.landing_page_url IS DISTINCT FROM source.landing_page_url OR
      target.pdf_s3_id IS DISTINCT FROM source.pdf_s3_id OR
      target.grobid_s3_id IS DISTINCT FROM source.grobid_s3_id OR
      target.mesh IS DISTINCT FROM source.mesh OR
      target.is_oa IS DISTINCT FROM source.is_oa OR
      target.is_oa_source IS DISTINCT FROM source.is_oa_source OR
      target.authors_exist IS DISTINCT FROM source.authors_exist OR
      target.affiliations_exist IS DISTINCT FROM source.affiliations_exist OR
      target.is_corresponding_exists IS DISTINCT FROM source.is_corresponding_exists OR
      target.best_doi IS DISTINCT FROM source.best_doi OR
      target.source_id IS DISTINCT FROM source.source_id
    )
THEN UPDATE SET
    /* identical UPDATE list as in the overall merge */
    target.provenance = source.provenance,
    target.native_id = source.native_id,
    target.native_id_namespace = source.native_id_namespace,
    target.title = COALESCE(source.title, target.title),
    target.normalized_title = COALESCE(source.normalized_title, target.normalized_title),
    target.authors = array_union(COALESCE(source.authors,array()),COALESCE(target.authors,array())),
    target.ids = array_union(COALESCE(source.ids,array()),COALESCE(target.ids,array())),
    target.type = source.type,
    target.version = source.version,
    target.license = source.license,
    target.language = source.language,
    target.published_date = source.published_date,
    target.created_date = source.created_date,
    target.updated_date = source.updated_date,
    target.issue = source.issue,
    target.volume = source.volume,
    target.first_page = source.first_page,
    target.last_page = source.last_page,
    target.is_retracted = source.is_retracted,
    target.abstract = source.abstract,
    target.source_name = source.source_name,
    target.publisher = source.publisher,
    target.funders = array_union(COALESCE(source.funders,array()),COALESCE(target.funders,array())),
    target.references = source.references,
    target.urls = array_union(COALESCE(source.urls,array()),COALESCE(target.urls,array())),
    target.pdf_url = source.pdf_url,
    target.landing_page_url = source.landing_page_url,
    target.pdf_s3_id = source.pdf_s3_id,
    target.grobid_s3_id = source.grobid_s3_id,
    target.mesh = source.mesh,
    target.is_oa = source.is_oa,
    target.is_oa_source = source.is_oa_source,
    target.abstract_inverted_index = source.abstract_inverted_index,
    target.authors_exist = source.authors_exist,
    target.affiliations_exist = source.affiliations_exist,
    target.is_corresponding_exists = source.is_corresponding_exists,
    target.best_doi = source.best_doi,
    target.source_id = source.source_id,
    target.openalex_updated_dt = current_timestamp();
-- USE ON FULL REFRESH
-- WHEN NOT MATCHED THEN INSERT (
-- work_id,
-- merge_key,
-- provenance,
-- native_id,
-- --true_native_id,
-- native_id_namespace,
-- title,
-- normalized_title,
-- authors,
-- ids,
-- type,
-- version,
-- license,
-- language,
-- published_date,
-- created_date,
-- updated_date,
-- issue,
-- volume,
-- first_page,
-- last_page,
-- is_retracted,
-- abstract,
-- source_name,
-- publisher,
-- funders,
-- references,
-- urls,
-- pdf_url,
-- landing_page_url,
-- pdf_s3_id,
-- grobid_s3_id,
-- mesh,
-- is_oa,
-- is_oa_source,
-- referenced_works_count,
-- referenced_works,
-- abstract_inverted_index,
-- authors_exist,
-- affiliations_exist,
-- is_corresponding_exists,
-- best_doi,
-- source_id,
-- openalex_created_dt,
-- openalex_updated_dt
-- ) VALUES (
-- null,
-- source.merge_key,
-- source.provenance,
-- source.native_id,
-- --source.true_native_id,
-- source.native_id_namespace,
-- source.title,
-- source.normalized_title,
-- source.authors,
-- source.ids,
-- source.type,
-- source.version,
-- source.license,
-- source.language,
-- source.published_date,
-- source.created_date,
-- source.updated_date,
-- source.issue,
-- source.volume,
-- source.first_page,
-- source.last_page,
-- source.is_retracted,
-- source.abstract,
-- source.source_name,
-- source.publisher,
-- source.funders,
-- source.references,
-- source.urls,
-- source.pdf_url,
-- source.landing_page_url,
-- source.pdf_s3_id,
-- source.grobid_s3_id,
-- source.mesh,
-- source.is_oa,
-- source.is_oa_source,
-- NULL, --referenced_works_count
-- NULL, --referenced_works is calculated from self-join
-- source.abstract_inverted_index,
-- source.authors_exist,
-- source.affiliations_exist,
-- source.is_corresponding_exists,
-- source.best_doi,
-- source.source_id,
-- current_date(),
-- current_timestamp()
-- );

-- COMMAND ----------

/* ====================================================================
   PASS B â€“ Original giant MERGE, skipping rows already handled by DOI
   ==================================================================== */
WITH counted_works AS (
    SELECT
        *,
        ROW_NUMBER() OVER(PARTITION BY merge_key, native_id, native_id_namespace, provenance ORDER BY updated_date DESC) AS rwcnt
    FROM identifier('openalex' || :env_suffix || '.works.locations_w_sources')
),
distinct_works AS (
    SELECT *
    FROM counted_works
    WHERE rwcnt = 1
),
-- ðŸš« drop rows whose DOI already exists in locations_mapped after DOI Update
distinct_works_no_doi AS (
  SELECT d.*
  FROM distinct_works d
  LEFT JOIN identifier('openalex' || :env_suffix || '.works.locations_mapped') lm
         ON lm.merge_key.doi = d.merge_key.doi
  WHERE  d.merge_key.doi IS NULL          -- keep no-DOI rows
     OR  lm.merge_key.doi IS NULL         -- keep DOI that wasnâ€™t updated in Pass A
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING distinct_works_no_doi AS source
ON target.merge_key IS NOT DISTINCT FROM source.merge_key
    AND target.native_id IS NOT DISTINCT FROM source.native_id
    AND target.native_id_namespace IS NOT DISTINCT FROM source.native_id_namespace
    AND (
      target.provenance = source.provenance OR 
      (target.provenance IN ('repo', 'repo_backfill') 
        AND source.provenance IN ('repo', 'repo_backfill'))
    )
    -- Ensure merge_key has at least one non-empty field 
    -- (avoid matching {null, null, null, (null or empty)})
    AND (
      (target.merge_key.doi IS NOT NULL AND
        TRIM(target.merge_key.doi) <> '') OR
      target.merge_key.pmid IS NOT NULL OR 
      target.merge_key.arxiv IS NOT NULL OR
      (target.merge_key.title_author IS NOT NULL AND
        target.merge_key.title_author <> '')
    )
WHEN MATCHED
AND (
      target.provenance IS DISTINCT FROM source.provenance OR
      target.native_id IS DISTINCT FROM source.native_id OR
      target.native_id_namespace IS DISTINCT FROM source.native_id_namespace OR
      target.title IS DISTINCT FROM source.title OR
      target.normalized_title IS DISTINCT FROM source.normalized_title OR
      target.type IS DISTINCT FROM source.type OR
      target.version IS DISTINCT FROM source.version OR
      target.license IS DISTINCT FROM source.license OR
      target.language IS DISTINCT FROM source.language OR
      target.published_date IS DISTINCT FROM source.published_date OR
      target.created_date IS DISTINCT FROM source.created_date OR
      target.issue IS DISTINCT FROM source.issue OR
      target.volume IS DISTINCT FROM source.volume OR
      target.first_page IS DISTINCT FROM source.first_page OR
      target.last_page IS DISTINCT FROM source.last_page OR
      target.is_retracted IS DISTINCT FROM source.is_retracted OR
      target.abstract IS DISTINCT FROM source.abstract OR
      target.source_name IS DISTINCT FROM source.source_name OR
      target.publisher IS DISTINCT FROM source.publisher OR
      target.pdf_url IS DISTINCT FROM source.pdf_url OR
      target.landing_page_url IS DISTINCT FROM source.landing_page_url OR
      target.pdf_s3_id IS DISTINCT FROM source.pdf_s3_id OR
      target.grobid_s3_id IS DISTINCT FROM source.grobid_s3_id OR
      target.mesh IS DISTINCT FROM source.mesh OR
      target.is_oa IS DISTINCT FROM source.is_oa OR
      target.is_oa_source IS DISTINCT FROM source.is_oa_source OR
      target.authors_exist IS DISTINCT FROM source.authors_exist OR
      target.affiliations_exist IS DISTINCT FROM source.affiliations_exist OR
      target.is_corresponding_exists IS DISTINCT FROM source.is_corresponding_exists OR
      target.best_doi IS DISTINCT FROM source.best_doi OR
      target.source_id IS DISTINCT FROM source.source_id
    )
THEN UPDATE SET
    target.provenance = source.provenance,
    target.native_id = source.native_id,
    --target.true_native_id = source.true_native_id,
    target.native_id_namespace = source.native_id_namespace,
    target.title = source.title,
    target.normalized_title = source.normalized_title,
    target.authors = array_union(coalesce(source.authors,array()),coalesce(target.authors,array())),
    target.ids = array_union(coalesce(source.ids,array()),coalesce(target.ids,array())),
    target.type = source.type,
    target.version = source.version,
    target.license = source.license,
    target.language = source.language,
    target.published_date = source.published_date,
    target.created_date = source.created_date,
    target.updated_date = source.updated_date,
    target.issue = source.issue,
    target.volume = source.volume,
    target.first_page = source.first_page,
    target.last_page = source.last_page,
    target.is_retracted = source.is_retracted,
    target.abstract = source.abstract,
    target.source_name = source.source_name,
    target.publisher = source.publisher,
    target.funders = array_union(coalesce(source.funders,array()),coalesce(target.funders,array())),
    target.references = source.references,
    target.urls = array_union(coalesce(source.urls,array()),coalesce(target.urls,array())),
    target.pdf_url = source.pdf_url,
    target.landing_page_url = source.landing_page_url,
    target.pdf_s3_id = source.pdf_s3_id,
    target.grobid_s3_id = source.grobid_s3_id,
    target.mesh = source.mesh,
    target.is_oa = source.is_oa,
    target.is_oa_source = source.is_oa_source,
    target.abstract_inverted_index = source.abstract_inverted_index,
    target.authors_exist = source.authors_exist,
    target.affiliations_exist = source.affiliations_exist,
    target.is_corresponding_exists = source.is_corresponding_exists,
    target.best_doi = source.best_doi,
    target.source_id = source.source_id,
    target.openalex_updated_dt = current_timestamp()
WHEN NOT MATCHED THEN INSERT (
    work_id,
    merge_key,
    provenance,
    native_id,
    --true_native_id,
    native_id_namespace,
    title,
    normalized_title,
    authors,
    ids,
    type,
    version,
    license,
    language,
    published_date,
    created_date,
    updated_date,
    issue,
    volume,
    first_page,
    last_page,
    is_retracted,
    abstract,
    source_name,
    publisher,
    funders,
    references,
    urls,
    pdf_url,
    landing_page_url,
    pdf_s3_id,
    grobid_s3_id,
    mesh,
    is_oa,
    is_oa_source,
    referenced_works_count,
    referenced_works,
    abstract_inverted_index,
    authors_exist,
    affiliations_exist,
    is_corresponding_exists,
    best_doi,
    source_id,
    openalex_created_dt,
    openalex_updated_dt
) VALUES (
    null,
    source.merge_key,
    source.provenance,
    source.native_id,
    --source.true_native_id,
    source.native_id_namespace,
    source.title,
    source.normalized_title,
    source.authors,
    source.ids,
    source.type,
    source.version,
    source.license,
    source.language,
    source.published_date,
    source.created_date,
    source.updated_date,
    source.issue,
    source.volume,
    source.first_page,
    source.last_page,
    source.is_retracted,
    source.abstract,
    source.source_name,
    source.publisher,
    source.funders,
    source.references,
    source.urls,
    source.pdf_url,
    source.landing_page_url,
    source.pdf_s3_id,
    source.grobid_s3_id,
    source.mesh,
    source.is_oa,
    source.is_oa_source,
    NULL, --referenced_works_count
    NULL, --referenced_works is calculated from self-join
    source.abstract_inverted_index,
    source.authors_exist,
    source.affiliations_exist,
    source.is_corresponding_exists,
    source.best_doi,
    source.source_id,
    current_date(),
    current_timestamp()
);

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Add new `locations_mapped` data to `work_id_map`
-- MAGIC Extract unmapped merge_keys from `locations_mapped` where `work_id IS NULL`, and merge them into `id_map` (insert new merge_keys).
-- MAGIC Inserted records will contain newly minted `work_id` values (they won't necessarily make it into `locations_mapped`).
-- MAGIC @TODO - look for a way to insert new prod data into work_id_map (maybe in Refresh Step directly)

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### Create merge and mint candidates from `locations_mapped` where `work_id IS NULL` (new inserts only)

-- COMMAND ----------

CREATE OR REPLACE TABLE identifier('openalex' || :env_suffix || '.works.work_id_map_new_candidates')
CLUSTER BY (doi, pmid, arxiv, title_author)
AS
SELECT
  merge_key.doi           AS doi,
  merge_key.pmid          AS pmid,
  merge_key.arxiv         AS arxiv,
  merge_key.title_author  AS title_author,
  (
    IF(merge_key.doi IS NOT NULL, 4, 0) +
    IF(merge_key.pmid IS NOT NULL, 3, 0) +
    IF(merge_key.arxiv IS NOT NULL, 2, 0) +
    IF(merge_key.title_author IS NOT NULL, 1, 0)
  ) AS key_score,
  MIN(openalex_created_dt) AS openalex_created_dt,
  MAX(openalex_updated_dt) AS openalex_updated_dt
FROM identifier('openalex' || :env_suffix || '.works.locations_mapped')
WHERE work_id IS NULL -- this ensures only freshly inserted locations are considered
GROUP BY doi, pmid, arxiv, title_author


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `DOI` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING (
  SELECT regexp_replace(doi, '[^a-zA-Z0-9\./-]', '') as cleaned_doi, *
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map_new_candidates')
  WHERE doi IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY regexp_replace(doi, '[^a-zA-Z0-9\./-]', '')
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON regexp_replace(target.doi, '[^a-zA-Z0-9\./-]', '') = cleaned_doi
WHEN MATCHED THEN UPDATE SET
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'doi'
WHEN NOT MATCHED THEN INSERT (
  doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'doi'
);


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING (
  SELECT *
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map_new_candidates')
  WHERE doi IS NULL AND pmid IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY pmid
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON target.pmid = source.pmid
WHEN MATCHED THEN UPDATE SET
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'pmid'
WHEN NOT MATCHED THEN INSERT (
  doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'pmid'
);

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING (
  SELECT *
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map_new_candidates')
  WHERE doi IS NULL AND pmid IS NULL AND arxiv IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY arxiv
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON target.arxiv = source.arxiv
WHEN MATCHED THEN UPDATE SET
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'arxiv'
WHEN NOT MATCHED THEN INSERT (
  doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'arxiv'
);


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING (
  SELECT *
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map_new_candidates')
  WHERE doi IS NULL AND pmid IS NULL AND arxiv IS NULL AND title_author IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY title_author
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON target.title_author = source.title_author
WHEN MATCHED THEN UPDATE SET
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'title_author'
WHEN NOT MATCHED THEN INSERT (
  doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'title_author'
);


-- COMMAND ----------



-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Use PROD data to set `work_id_map.paper_id = [table].paper_id` when matched

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### Merge to `work_id_map` using `openalex.mid.work.lower_doi`.

-- COMMAND ----------

-- Merge in legacy paper_id's for DOI
-- RETHINK HOW WE ARE GOING TO INSERT NEW PRODUCTION IDs into work_id_map that isn't driven by locations 
-- in need of ids (maybe that's not a problem as long as we do one full restate?)
WITH paper_ids AS (
  SELECT
    regexp_replace(w.doi_lower, '[^a-zA-Z0-9.]', '') AS cleaned_doi,
    MIN(w.paper_id) AS paper_id, -- Choose the smallest legacy ID as the canonical one
    MAX(w.created_date) AS created_dt,
    MAX(w.updated_date) AS updated_dt
  FROM openalex.mid.work w
  WHERE w.doi_lower IS NOT NULL
  GROUP BY cleaned_doi
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING paper_ids AS source
  -- The ON condition also cleans the target DOI to ensure a consistent match.
  ON regexp_replace(LOWER(target.doi), '[^a-zA-Z0-9.]', '') = source.cleaned_doi
WHEN MATCHED AND target.paper_id IS NULL THEN
UPDATE SET
  target.paper_id = source.paper_id,
  target.openalex_created_dt = source.created_dt,
  target.openalex_updated_dt = source.updated_dt;
-- WHEN NOT MATCHED AND source.paper_id > target.paper_id THEN INSERT  
-- () 
-- VALUES (
--   source.paper_id,
--   source.doi,
--   source.created_dt,
--   source.updated_dt
-- );

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match using `mid.work.attribute_value`.
-- MAGIC Where `attribute_type = 2`

-- COMMAND ----------

WITH paper_ids AS (
  SELECT
    x.attribute_value AS pmid,
    MIN(w.paper_id) AS paper_id,      -- Choose the smallest legacy ID as the canonical one
    MAX(w.created_date) AS created_dt,
    MAX(w.updated_date) AS updated_dt
  FROM openalex.mid.work w
  JOIN openalex.mid.work_extra_ids x ON w.paper_id = x.paper_id
  WHERE x.attribute_type = 2 -- Corresponds to pmid
  GROUP BY x.attribute_value
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING paper_ids AS source
  ON LOWER(TRIM(target.pmid)) = LOWER(TRIM(source.pmid))
  AND target.paper_id IS NULL -- Only match rows that need a paper_id
WHEN MATCHED THEN
UPDATE SET
  target.paper_id = source.paper_id,
  target.openalex_created_dt = source.created_dt,
  target.openalex_updated_dt = source.updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match using `mid.work.arxiv_id`

-- COMMAND ----------

WITH paper_ids AS (
  SELECT
    w.arxiv_id,
    MIN(w.paper_id) AS paper_id,      -- Choose the smallest legacy ID as the canonical one
    MAX(w.created_date) AS created_dt,
    MAX(w.updated_date) AS updated_dt
  FROM openalex.mid.work w
  WHERE w.arxiv_id IS NOT NULL
  GROUP BY w.arxiv_id
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING paper_ids AS source
  ON LOWER(TRIM(target.arxiv)) = LOWER(TRIM(source.arxiv_id))
  AND target.paper_id IS NULL -- Only match rows that need a paper_id
WHEN MATCHED THEN
UPDATE SET
  target.paper_id = source.paper_id,
  target.openalex_created_dt = source.created_dt,
  target.openalex_updated_dt = source.updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match using `CONCAT(mid.work.normalize_title, '_', mid.affiliations.match_title)` 

-- COMMAND ----------

-- Build paper_ids one-step (already lower-cased / trimmed)
WITH affiliation_authors AS (
  SELECT paper_id, MAX(COALESCE(match_author, '')) as author_key
  FROM openalex.mid.affiliation
  WHERE author_sequence_number = 1
  GROUP BY paper_id
),
paper_ids AS (
  SELECT      
      MIN(w.paper_id) AS paper_id, -- choose smallest legacy id
      CONCAT(w.normalized_title, '_', aa.author_key) as title_author,
      MAX(w.created_date) AS created_dt,
      MAX(w.updated_date) AS updated_dt
  FROM openalex.mid.work w
  JOIN affiliation_authors aa USING (paper_id)
  WHERE w.arxiv_id IS NULL
    AND (w.doi IS NULL OR w.doi = '')
    AND LENGTH(w.normalized_title) > 0
  GROUP BY title_author
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING paper_ids AS source
  ON target.title_author = source.title_author
  AND target.paper_id IS NULL
WHEN MATCHED THEN
UPDATE SET
  target.paper_id = source.paper_id,
  target.openalex_created_dt = source.created_dt,
  target.openalex_updated_dt = source.updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Set `locations_mapped.work_id = work_id_map.paper_id` when matched

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `DOI` match

-- COMMAND ----------

-- Merge on DOI matches
WITH ids AS (
  SELECT DISTINCT
    doi,
    MIN(paper_id) AS paper_id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NOT NULL
    AND doi IS NOT NULL
  GROUP BY doi
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.doi = source.doi
  AND (target.work_id IS NULL OR target.work_id > source.paper_id)
WHEN MATCHED
THEN UPDATE SET 
  target.work_id = source.paper_id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match

-- COMMAND ----------

 WITH ids AS (
  SELECT DISTINCT
    pmid as pmid,
    MIN(paper_id) AS paper_id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NOT NULL
    AND pmid IS NOT NULL
  GROUP BY pmid
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source
  ON target.merge_key.pmid = source.pmid
  AND (target.work_id IS NULL OR target.work_id > source.paper_id)
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.paper_id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match

-- COMMAND ----------

-- Merge on ARXIV matches
WITH ids AS (
  SELECT DISTINCT
    arxiv,
    MIN(paper_id) AS paper_id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NOT NULL
    AND arxiv IS NOT NULL
  GROUP BY arxiv
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.arxiv = source.arxiv
  AND (target.work_id IS NULL OR target.work_id > source.paper_id)
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.paper_id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match

-- COMMAND ----------

WITH ids AS (
  SELECT DISTINCT
    title_author,
    MIN(paper_id) AS paper_id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NOT NULL
    AND (doi IS NULL AND pmid IS NULL AND arxiv IS NULL)
    AND title_author IS NOT NULL
  GROUP BY title_author
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.title_author = source.title_author
  AND (target.work_id IS NULL OR target.work_id > source.paper_id)
  AND LENGTH(source.title_author) > 20
WHEN MATCHED THEN UPDATE SET
  target.work_id = source.paper_id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Populate MINTED `locations_mapped.work_id` from `works_id_map` WHERE work_id is NULL
-- MAGIC This is not necessarily minting only - `MIN(id)` is used which may result in a match to earlier `work_id`

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `DOI` match

-- COMMAND ----------

WITH ids AS (
  SELECT
    doi as doi,
    MIN(id) AS id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NULL
    AND doi IS NOT NULL
  GROUP BY doi
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.doi = source.doi
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match

-- COMMAND ----------

-- Merge on PMID matches
WITH ids AS (
  SELECT DISTINCT
    pmid as pmid,
    MIN(id) AS id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NULL
    AND pmid IS NOT NULL
  GROUP BY pmid
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.pmid = source.pmid
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match

-- COMMAND ----------

-- Merge on ARXIV matches
WITH ids AS (
  SELECT DISTINCT
    arxiv as arxiv,
    MIN(id) AS id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NULL
    AND arxiv IS NOT NULL
  GROUP BY arxiv
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.arxiv = source.arxiv
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match

-- COMMAND ----------

-- Merge on TITLE_AUTHOR matches
WITH ids AS (
  SELECT DISTINCT
    title_author,
    MIN(id) AS id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NULL
    AND (doi IS NULL AND pmid IS NULL AND arxiv IS NULL)
    AND title_author IS NOT NULL
  GROUP BY title_author
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.title_author = source.title_author
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Insert legacy `paper_id`'s based on mag id

-- COMMAND ----------

WITH mag_walden_works AS (
  SELECT
    get(filter(ids, x -> x.namespace = 'mag').id, 0) AS legacy_work_id,
    MAX(get(filter(ids, x -> x.namespace = 'mag').id, 0)) OVER (
      PARTITION BY work_id
    ) AS assigned_work_id,
    work_id
  FROM identifier('openalex' || :env_suffix || '.works.locations_mapped')
  WHERE provenance = 'mag'
),
updated_mag_walden_works AS (
  SELECT
    work_id AS current_work_id,
    COALESCE(legacy_work_id, assigned_work_id) AS new_work_id
  FROM mag_walden_works
  WHERE COALESCE(legacy_work_id, assigned_work_id) IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY work_id
    ORDER BY COALESCE(legacy_work_id, assigned_work_id)
  ) = 1
)

MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING updated_mag_walden_works AS source
ON target.work_id = source.current_work_id
WHEN MATCHED AND target.work_id > 6600000000 THEN -- only overwrite assigned work ids - not legacy
UPDATE SET
  target.work_id = source.new_work_id;


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Insert legacy `paper_id`'s based on pmh_id

-- COMMAND ----------

WITH pmh_mapping AS (
  -- select the lowest work_id (since we have multiple PMH IDs for the same work and a legacy work_id 
  -- is always lower than a newly minted work_id, which increments starting at 6600000001).
  SELECT LOWER(pmh_id) AS pmh_id, MIN(work_id) AS legacy_work_id
  FROM openalex.works_poc.work_id_to_pmh_id_final
  GROUP BY pmh_id
),
repo_walden_works AS (
  SELECT *,
         CASE WHEN provenance IN ('repo', 'repo_backfill') THEN LOWER(native_id) END AS pmh_id_walden
  FROM identifier('openalex' || :env_suffix || '.works.locations_mapped')
  WHERE provenance IN ('repo', 'repo_backfill') AND work_id > 6600000000
),
updated_repo_walden_works AS ( --partition to get MIN legacy_work_id if multiple per work_id exist
  SELECT
    r.work_id AS current_work_id,
    m.legacy_work_id
  FROM repo_walden_works r
  LEFT JOIN pmh_mapping m ON r.pmh_id_walden = m.pmh_id
  WHERE m.legacy_work_id IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY r.work_id
    ORDER BY m.legacy_work_id ASC
  ) = 1
)

MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING updated_repo_walden_works AS source
ON target.work_id = source.current_work_id
WHEN MATCHED THEN UPDATE SET
  target.work_id = source.legacy_work_id;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Create `referenced_works` from `references` dois via self-join to get `work_id` values

-- COMMAND ----------

WITH exploded_dois AS (
  SELECT
    work_id,
    EXPLODE(references.doi) AS doi    
  FROM identifier('openalex' || :env_suffix || '.works.locations_mapped')
),
mapped_dois AS (
  SELECT
    ed.work_id AS citing_work_id,
    lm.work_id AS cited_work_id
  FROM exploded_dois ed
  JOIN identifier('openalex' || :env_suffix || '.works.locations_mapped') lm 
    ON LOWER(ed.doi) = LOWER(lm.best_doi)
  WHERE ed.doi IS NOT NULL AND lm.best_doi IS NOT NULL
),
aggregated_refs AS (
  SELECT
    citing_work_id,
    SORT_ARRAY(COLLECT_SET(cited_work_id)) AS referenced_works
  FROM mapped_dois
  GROUP BY citing_work_id
)

MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING aggregated_refs AS source
ON target.work_id = source.citing_work_id
WHEN MATCHED AND (
  target.referenced_works IS DISTINCT FROM source.referenced_works OR
  target.referenced_works_count IS DISTINCT FROM SIZE(source.referenced_works)
)
THEN UPDATE SET
  target.referenced_works = source.referenced_works,
  target.referenced_works_count = SIZE(source.referenced_works);


-- COMMAND ----------

SELECT format_number(COUNT(*), 0) as row_count
FROM openalex.works.locations_mapped --618,448,502 - July 16th, 618,777,313 - July 17th

-- COMMAND ----------


