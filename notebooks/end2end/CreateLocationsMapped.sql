-- Databricks notebook source
-- MAGIC %md
-- MAGIC ### Create `locations_mapped` and `work_id_map` tables IF THEY DO NOT EXIST
-- MAGIC No table re-creation and full idempotency are new features.

-- COMMAND ----------

CREATE TABLE IF NOT EXISTS identifier('openalex' || :env_suffix || '.works.locations_mapped') (
  work_id BIGINT,
  work_id_source STRING,
  merge_key STRUCT<doi: STRING, pmid: STRING, arxiv: STRING, title_author: STRING>,
  key_lineage STRING,
  provenance STRING,
  native_id STRING,
  --true_native_id STRING,
  native_id_namespace STRING,
  title STRING,
  normalized_title STRING,
  authors ARRAY<STRUCT<given: STRING, family: STRING, name: STRING, orcid: STRING, affiliations: ARRAY<STRUCT<name: STRING, department: STRING, ror_id: STRING>>, is_corresponding: BOOLEAN, author_key: STRING>>,
  ids ARRAY<STRUCT<id: STRING, namespace: STRING, relationship: STRING>>,
  type STRING,
  version STRING,
  license STRING,
  language STRING,
  language_classification struct<language: string, score: double>,
  published_date DATE,
  created_date DATE,
  updated_date DATE,
  issue STRING,
  volume STRING,
  first_page STRING,
  last_page STRING,
  is_retracted BOOLEAN,
  abstract STRING,
  source_name STRING,
  publisher STRING,
  funders ARRAY<STRUCT<doi: STRING, ror: STRING, name: STRING, awards: ARRAY<STRING>>>,
  references ARRAY<STRUCT<doi: STRING, pmid: STRING, arxiv: STRING, title: STRING, authors: STRING, year: STRING, raw: STRING>>,
  urls ARRAY<STRUCT<url: STRING, content_type: STRING>>,
  pdf_url STRING,
  landing_page_url STRING,
  pdf_s3_id STRING,
  grobid_s3_id STRING,
  mesh STRING,
  is_oa BOOLEAN,
  is_oa_source BOOLEAN,
  referenced_works_count INT,
  referenced_works ARRAY<BIGINT>,
  abstract_inverted_index STRING,
  authors_exist BOOLEAN,
  affiliations_exist BOOLEAN,
  is_corresponding_exists BOOLEAN,
  best_doi STRING,
  source_id BIGINT,
  openalex_created_dt DATE,
  openalex_updated_dt TIMESTAMP)
USING delta
CLUSTER BY (merge_key.doi, merge_key.pmid, merge_key.arxiv, merge_key.title_author)
TBLPROPERTIES (
  'delta.checkpoint.writeStatsAsJson' = 'false',
  'delta.checkpoint.writeStatsAsStruct' = 'true',
  'delta.enableDeletionVectors' = 'true',
  'delta.feature.deletionVectors' = 'supported',
  'delta.feature.rowTracking' = 'supported',
  'delta.feature.v2Checkpoint' = 'supported');

CREATE TABLE IF NOT EXISTS identifier('openalex' || :env_suffix || '.works.work_id_map') (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 6600000001 INCREMENT BY 1),
  paper_id STRING,
  doi STRING,
  pmid STRING,
  arxiv STRING,
  title_author STRING,
  work_id_source STRING,
  openalex_created_dt DATE,
  openalex_updated_dt TIMESTAMP
)
CLUSTER BY (doi, pmid, arxiv, title_author)
TBLPROPERTIES (
  'delta.deletedFileRetentionDuration' = '60 days', -- default is 7
  'delta.logRetentionDuration' = '60 days',         -- default is 30  
  'delta.checkpoint.writeStatsAsJson' = 'false',
  'delta.checkpoint.writeStatsAsStruct' = 'true',
  'delta.enableDeletionVectors' = 'true',
  'delta.feature.deletionVectors' = 'supported',
  'delta.feature.rowTracking' = 'supported',
  'delta.feature.v2Checkpoint' = 'supported');  

-- COMMAND ----------

-- MAGIC %md
-- MAGIC > ### Merge deduplicated records from `locations_w_sources` into `locations_mapped`
-- MAGIC Merge deduplicated records from `locations_w_sources` into `locations_mapped`, inserting rows with `work_id = NULL` and updating others.

-- COMMAND ----------

-- MAGIC %md
-- MAGIC #### First merge update by DOI to avoid overly wide merge on overall merge key that produces too many insertions

-- COMMAND ----------

WITH distinct_works AS (
    SELECT  *,
            ROW_NUMBER() OVER (
               PARTITION BY merge_key,
                            native_id,
                            native_id_namespace,
                            provenance
               ORDER BY updated_date DESC) AS rwcnt
    FROM identifier('openalex' || :env_suffix || '.works.locations_w_sources')
    QUALIFY rwcnt = 1
)
/* ==========================================================
   PASS A – DOI-only UPDATE (no inserts)
   ========================================================== */
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped')    AS target
USING distinct_works                                                             AS source
ON target.merge_key.doi = source.merge_key.doi
    AND (
      target.provenance = source.provenance OR 
      (target.provenance IN ('repo', 'repo_backfill') AND source.provenance IN ('repo', 'repo_backfill'))
    ) 
    -- needed because repo and repo_backfill records with the same ID are switching back and forth
    -- maybe in the union step
    AND target.native_id IS NOT DISTINCT FROM source.native_id
    AND target.native_id_namespace IS NOT DISTINCT FROM source.native_id_namespace
    AND target.merge_key.doi IS NOT NULL
WHEN MATCHED
AND (
      target.provenance IS DISTINCT FROM source.provenance OR
      target.native_id IS DISTINCT FROM source.native_id OR
      target.native_id_namespace IS DISTINCT FROM source.native_id_namespace OR
      target.title IS DISTINCT FROM source.title OR
      target.normalized_title IS DISTINCT FROM source.normalized_title OR
      target.type IS DISTINCT FROM source.type OR
      target.version IS DISTINCT FROM source.version OR
      target.license IS DISTINCT FROM source.license OR
      target.language IS DISTINCT FROM source.language OR
      target.published_date IS DISTINCT FROM source.published_date OR
      target.created_date IS DISTINCT FROM source.created_date OR
      target.issue IS DISTINCT FROM source.issue OR
      target.volume IS DISTINCT FROM source.volume OR
      target.first_page IS DISTINCT FROM source.first_page OR
      target.last_page IS DISTINCT FROM source.last_page OR
      target.is_retracted IS DISTINCT FROM source.is_retracted OR
      target.abstract IS DISTINCT FROM source.abstract OR
      target.source_name IS DISTINCT FROM source.source_name OR
      target.publisher IS DISTINCT FROM source.publisher OR
      target.pdf_url IS DISTINCT FROM source.pdf_url OR
      target.landing_page_url IS DISTINCT FROM source.landing_page_url OR
      target.pdf_s3_id IS DISTINCT FROM source.pdf_s3_id OR
      target.grobid_s3_id IS DISTINCT FROM source.grobid_s3_id OR
      target.mesh IS DISTINCT FROM source.mesh OR
      target.is_oa IS DISTINCT FROM source.is_oa OR
      target.is_oa_source IS DISTINCT FROM source.is_oa_source OR
      target.authors_exist IS DISTINCT FROM source.authors_exist OR
      target.affiliations_exist IS DISTINCT FROM source.affiliations_exist OR
      target.is_corresponding_exists IS DISTINCT FROM source.is_corresponding_exists OR
      target.best_doi IS DISTINCT FROM source.best_doi OR
      target.source_id IS DISTINCT FROM source.source_id
    )
THEN UPDATE SET
    /* identical UPDATE list as in the overall merge */
    target.provenance = source.provenance,
    target.native_id = source.native_id,
    target.native_id_namespace = source.native_id_namespace,
    target.title = COALESCE(source.title, target.title),
    target.normalized_title = COALESCE(source.normalized_title, target.normalized_title),
    target.authors = array_union(COALESCE(source.authors,array()),COALESCE(target.authors,array())),
    target.ids = array_union(COALESCE(source.ids,array()),COALESCE(target.ids,array())),
    target.type = source.type,
    target.version = source.version,
    target.license = source.license,
    target.language = source.language,
    target.published_date = source.published_date,
    target.created_date = source.created_date,
    target.updated_date = source.updated_date,
    target.issue = source.issue,
    target.volume = source.volume,
    target.first_page = source.first_page,
    target.last_page = source.last_page,
    target.is_retracted = source.is_retracted,
    target.abstract = source.abstract,
    target.source_name = source.source_name,
    target.publisher = source.publisher,
    target.funders = array_union(COALESCE(source.funders,array()),COALESCE(target.funders,array())),
    target.references = source.references,
    target.urls = array_union(COALESCE(source.urls,array()),COALESCE(target.urls,array())),
    target.pdf_url = source.pdf_url,
    target.landing_page_url = source.landing_page_url,
    target.pdf_s3_id = source.pdf_s3_id,
    target.grobid_s3_id = source.grobid_s3_id,
    target.mesh = source.mesh,
    target.is_oa = source.is_oa,
    target.is_oa_source = source.is_oa_source,
    target.abstract_inverted_index = source.abstract_inverted_index,
    target.authors_exist = source.authors_exist,
    target.affiliations_exist = source.affiliations_exist,
    target.is_corresponding_exists = source.is_corresponding_exists,
    target.best_doi = source.best_doi,
    target.source_id = source.source_id,
    target.openalex_updated_dt = current_timestamp();
-- USE ON FULL REFRESH
-- WHEN NOT MATCHED THEN INSERT (
-- work_id,
-- merge_key,
-- provenance,
-- native_id,
-- --true_native_id,
-- native_id_namespace,
-- title,
-- normalized_title,
-- authors,
-- ids,
-- type,
-- version,
-- license,
-- language,
-- published_date,
-- created_date,
-- updated_date,
-- issue,
-- volume,
-- first_page,
-- last_page,
-- is_retracted,
-- abstract,
-- source_name,
-- publisher,
-- funders,
-- references,
-- urls,
-- pdf_url,
-- landing_page_url,
-- pdf_s3_id,
-- grobid_s3_id,
-- mesh,
-- is_oa,
-- is_oa_source,
-- referenced_works_count,
-- referenced_works,
-- abstract_inverted_index,
-- authors_exist,
-- affiliations_exist,
-- is_corresponding_exists,
-- best_doi,
-- source_id,
-- openalex_created_dt,
-- openalex_updated_dt
-- ) VALUES (
-- null,
-- source.merge_key,
-- source.provenance,
-- source.native_id,
-- --source.true_native_id,
-- source.native_id_namespace,
-- source.title,
-- source.normalized_title,
-- source.authors,
-- source.ids,
-- source.type,
-- source.version,
-- source.license,
-- source.language,
-- source.published_date,
-- source.created_date,
-- source.updated_date,
-- source.issue,
-- source.volume,
-- source.first_page,
-- source.last_page,
-- source.is_retracted,
-- source.abstract,
-- source.source_name,
-- source.publisher,
-- source.funders,
-- source.references,
-- source.urls,
-- source.pdf_url,
-- source.landing_page_url,
-- source.pdf_s3_id,
-- source.grobid_s3_id,
-- source.mesh,
-- source.is_oa,
-- source.is_oa_source,
-- NULL, --referenced_works_count
-- NULL, --referenced_works is calculated from self-join
-- source.abstract_inverted_index,
-- source.authors_exist,
-- source.affiliations_exist,
-- source.is_corresponding_exists,
-- source.best_doi,
-- source.source_id,
-- current_date(),
-- current_timestamp()
-- );

-- COMMAND ----------

/* ====================================================================
   PASS B – Original giant MERGE, skipping rows already handled by DOI
   ==================================================================== */
WITH counted_works AS (
    SELECT
        *,
        ROW_NUMBER() OVER(PARTITION BY merge_key, native_id, native_id_namespace, provenance ORDER BY updated_date DESC) AS rwcnt
    FROM identifier('openalex' || :env_suffix || '.works.locations_w_sources')
),
distinct_works AS (
    SELECT *
    FROM counted_works
    WHERE rwcnt = 1
),
distinct_works_no_doi AS (
  SELECT d.*
  FROM distinct_works d
  LEFT JOIN identifier('openalex' || :env_suffix || '.works.locations_mapped') lm
         ON lm.merge_key.doi = d.merge_key.doi
         AND lm.native_id = d.native_id
         AND lm.native_id_namespace = d.native_id_namespace
  WHERE  d.merge_key.doi IS NULL          
     OR  lm.merge_key.doi IS NULL         
     OR  (d.merge_key.pmid IS NOT NULL AND lm.native_id IS NULL)  -- new PMID records only
     OR  (d.merge_key.arxiv IS NOT NULL AND lm.native_id IS NULL) -- new arXiv records only
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING distinct_works_no_doi AS source
ON target.merge_key IS NOT DISTINCT FROM source.merge_key
    AND target.native_id IS NOT DISTINCT FROM source.native_id
    AND target.native_id_namespace IS NOT DISTINCT FROM source.native_id_namespace
    AND (
      target.provenance = source.provenance OR 
      (target.provenance IN ('repo', 'repo_backfill') 
        AND source.provenance IN ('repo', 'repo_backfill'))
    )
    -- Ensure merge_key has at least one non-empty field 
    -- (avoid matching {null, null, null, (null or empty)})
    AND (
      (target.merge_key.doi IS NOT NULL AND
        TRIM(target.merge_key.doi) <> '') OR
      target.merge_key.pmid IS NOT NULL OR 
      target.merge_key.arxiv IS NOT NULL OR
      (target.merge_key.title_author IS NOT NULL AND
        target.merge_key.title_author <> '')
    )
WHEN MATCHED
AND (
      target.provenance IS DISTINCT FROM source.provenance OR
      target.native_id IS DISTINCT FROM source.native_id OR
      target.native_id_namespace IS DISTINCT FROM source.native_id_namespace OR
      target.title IS DISTINCT FROM source.title OR
      target.normalized_title IS DISTINCT FROM source.normalized_title OR
      target.type IS DISTINCT FROM source.type OR
      target.version IS DISTINCT FROM source.version OR
      target.license IS DISTINCT FROM source.license OR
      target.language IS DISTINCT FROM source.language OR
      target.published_date IS DISTINCT FROM source.published_date OR
      target.created_date IS DISTINCT FROM source.created_date OR
      target.issue IS DISTINCT FROM source.issue OR
      target.volume IS DISTINCT FROM source.volume OR
      target.first_page IS DISTINCT FROM source.first_page OR
      target.last_page IS DISTINCT FROM source.last_page OR
      target.is_retracted IS DISTINCT FROM source.is_retracted OR
      target.abstract IS DISTINCT FROM source.abstract OR
      target.source_name IS DISTINCT FROM source.source_name OR
      target.publisher IS DISTINCT FROM source.publisher OR
      target.pdf_url IS DISTINCT FROM source.pdf_url OR
      target.landing_page_url IS DISTINCT FROM source.landing_page_url OR
      target.pdf_s3_id IS DISTINCT FROM source.pdf_s3_id OR
      target.grobid_s3_id IS DISTINCT FROM source.grobid_s3_id OR
      target.mesh IS DISTINCT FROM source.mesh OR
      target.is_oa IS DISTINCT FROM source.is_oa OR
      target.is_oa_source IS DISTINCT FROM source.is_oa_source OR
      target.authors_exist IS DISTINCT FROM source.authors_exist OR
      target.affiliations_exist IS DISTINCT FROM source.affiliations_exist OR
      target.is_corresponding_exists IS DISTINCT FROM source.is_corresponding_exists OR
      target.best_doi IS DISTINCT FROM source.best_doi OR
      target.source_id IS DISTINCT FROM source.source_id
    )
THEN UPDATE SET
    target.provenance = source.provenance,
    target.native_id = source.native_id,
    --target.true_native_id = source.true_native_id,
    target.native_id_namespace = source.native_id_namespace,
    target.title = source.title,
    target.normalized_title = source.normalized_title,
    target.authors = array_union(coalesce(source.authors,array()),coalesce(target.authors,array())),
    target.ids = array_union(coalesce(source.ids,array()),coalesce(target.ids,array())),
    target.type = source.type,
    target.version = source.version,
    target.license = source.license,
    target.language = source.language,
    target.published_date = source.published_date,
    target.created_date = source.created_date,
    target.updated_date = source.updated_date,
    target.issue = source.issue,
    target.volume = source.volume,
    target.first_page = source.first_page,
    target.last_page = source.last_page,
    target.is_retracted = source.is_retracted,
    target.abstract = source.abstract,
    target.source_name = source.source_name,
    target.publisher = source.publisher,
    target.funders = array_union(coalesce(source.funders,array()),coalesce(target.funders,array())),
    target.references = source.references,
    target.urls = array_union(coalesce(source.urls,array()),coalesce(target.urls,array())),
    target.pdf_url = source.pdf_url,
    target.landing_page_url = source.landing_page_url,
    target.pdf_s3_id = source.pdf_s3_id,
    target.grobid_s3_id = source.grobid_s3_id,
    target.mesh = source.mesh,
    target.is_oa = source.is_oa,
    target.is_oa_source = source.is_oa_source,
    target.abstract_inverted_index = source.abstract_inverted_index,
    target.authors_exist = source.authors_exist,
    target.affiliations_exist = source.affiliations_exist,
    target.is_corresponding_exists = source.is_corresponding_exists,
    target.best_doi = source.best_doi,
    target.source_id = source.source_id,
    target.openalex_updated_dt = current_timestamp()
WHEN NOT MATCHED THEN INSERT (
    work_id,
    merge_key,
    provenance,
    native_id,
    --true_native_id,
    native_id_namespace,
    title,
    normalized_title,
    authors,
    ids,
    type,
    version,
    license,
    language,
    published_date,
    created_date,
    updated_date,
    issue,
    volume,
    first_page,
    last_page,
    is_retracted,
    abstract,
    source_name,
    publisher,
    funders,
    references,
    urls,
    pdf_url,
    landing_page_url,
    pdf_s3_id,
    grobid_s3_id,
    mesh,
    is_oa,
    is_oa_source,
    referenced_works_count,
    referenced_works,
    abstract_inverted_index,
    authors_exist,
    affiliations_exist,
    is_corresponding_exists,
    best_doi,
    source_id,
    openalex_created_dt,
    openalex_updated_dt
) VALUES (
    null,
    source.merge_key,
    source.provenance,
    source.native_id,
    --source.true_native_id,
    source.native_id_namespace,
    source.title,
    source.normalized_title,
    source.authors,
    source.ids,
    source.type,
    source.version,
    source.license,
    source.language,
    source.published_date,
    source.created_date,
    source.updated_date,
    source.issue,
    source.volume,
    source.first_page,
    source.last_page,
    source.is_retracted,
    source.abstract,
    source.source_name,
    source.publisher,
    source.funders,
    source.references,
    source.urls,
    source.pdf_url,
    source.landing_page_url,
    source.pdf_s3_id,
    source.grobid_s3_id,
    source.mesh,
    source.is_oa,
    source.is_oa_source,
    NULL, --referenced_works_count
    NULL, --referenced_works is calculated from self-join
    source.abstract_inverted_index,
    source.authors_exist,
    source.affiliations_exist,
    source.is_corresponding_exists,
    source.best_doi,
    source.source_id,
    current_date(),
    current_timestamp()
);

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Add new `locations_mapped` data to `work_id_map`
-- MAGIC Extract unmapped merge_keys from `locations_mapped` where `work_id IS NULL`, and merge them into `id_map` (insert new merge_keys).
-- MAGIC Inserted records will contain newly minted `work_id` values (they won't necessarily make it into `locations_mapped`).
-- MAGIC @TODO - look for a way to insert new prod data into work_id_map (maybe in Refresh Step directly)

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### Create merge and mint candidates from `locations_mapped` where `work_id IS NULL` (new inserts only)

-- COMMAND ----------

CREATE OR REPLACE TABLE identifier('openalex' || :env_suffix || '.works.work_id_map_new_candidates')
CLUSTER BY (doi, pmid, arxiv, title_author)
AS
SELECT
  merge_key.doi           AS doi,
  merge_key.pmid          AS pmid,
  merge_key.arxiv         AS arxiv,
  merge_key.title_author  AS title_author,
  (
    IF(merge_key.doi IS NOT NULL, 4, 0) +
    IF(merge_key.pmid IS NOT NULL, 3, 0) +
    IF(merge_key.arxiv IS NOT NULL, 2, 0) +
    IF(merge_key.title_author IS NOT NULL, 1, 0)
  ) AS key_score,
  MIN(openalex_created_dt) AS openalex_created_dt,
  MAX(openalex_updated_dt) AS openalex_updated_dt
FROM identifier('openalex' || :env_suffix || '.works.locations_mapped')
WHERE work_id IS NULL -- this ensures only freshly inserted locations are considered
GROUP BY doi, pmid, arxiv, title_author


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `DOI` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING (
  SELECT regexp_replace(doi, '[^a-zA-Z0-9\./-]', '') as cleaned_doi, *
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map_new_candidates')
  WHERE doi IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY regexp_replace(doi, '[^a-zA-Z0-9\./-]', '')
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON regexp_replace(target.doi, '[^a-zA-Z0-9\./-]', '') = cleaned_doi
WHEN MATCHED THEN UPDATE SET
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'doi'
WHEN NOT MATCHED THEN INSERT (
  doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'doi'
);


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING (
  SELECT *
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map_new_candidates')
  WHERE doi IS NULL AND pmid IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY pmid
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON target.pmid = source.pmid
WHEN MATCHED THEN UPDATE SET
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'pmid'
WHEN NOT MATCHED THEN INSERT (
  doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'pmid'
);

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING (
  SELECT *
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map_new_candidates')
  WHERE doi IS NULL AND pmid IS NULL AND arxiv IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY arxiv
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON target.arxiv = source.arxiv
WHEN MATCHED THEN UPDATE SET
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'arxiv'
WHEN NOT MATCHED THEN INSERT (
  doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'arxiv'
);


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING (
  SELECT *
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map_new_candidates')
  WHERE doi IS NULL AND pmid IS NULL AND arxiv IS NULL AND title_author IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY title_author
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON target.title_author = source.title_author
WHEN MATCHED THEN UPDATE SET
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'title_author'
WHEN NOT MATCHED THEN INSERT (
  doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'title_author'
);


-- COMMAND ----------



-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Use PROD data to set `work_id_map.paper_id = [table].paper_id` when matched

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### Merge to `work_id_map` using `openalex.mid.work.lower_doi`.

-- COMMAND ----------

-- Merge in legacy paper_id's for DOI
-- RETHINK HOW WE ARE GOING TO INSERT NEW PRODUCTION IDs into work_id_map that isn't driven by locations 
-- in need of ids (maybe that's not a problem as long as we do one full restate?)
WITH paper_ids AS (
  SELECT
    regexp_replace(w.doi_lower, '[^a-zA-Z0-9.]', '') AS cleaned_doi,
    MIN(w.paper_id) AS paper_id, -- Choose the smallest legacy ID as the canonical one
    MIN(DATE(w.created_date)) AS created_dt,
    MAX(DATE(w.updated_date)) AS updated_dt
  FROM openalex.mid.work w
  WHERE w.doi_lower IS NOT NULL
  GROUP BY cleaned_doi
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING paper_ids AS source
  -- The ON condition also cleans the target DOI to ensure a consistent match.
  ON regexp_replace(LOWER(target.doi), '[^a-zA-Z0-9.]', '') = source.cleaned_doi
WHEN MATCHED AND target.paper_id IS NULL THEN
UPDATE SET
  target.paper_id = source.paper_id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.created_dt),
  target.openalex_updated_dt = source.updated_dt;
-- WHEN NOT MATCHED AND source.paper_id > target.paper_id THEN INSERT  
-- () 
-- VALUES (
--   source.paper_id,
--   source.doi,
--   source.created_dt,
--   source.updated_dt
-- );

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match using `mid.work.attribute_value`.
-- MAGIC Where `attribute_type = 2`

-- COMMAND ----------

WITH paper_ids AS (
  SELECT
    x.attribute_value AS pmid,
    MIN(w.paper_id) AS paper_id,      -- Choose the smallest legacy ID as the canonical one
    MIN(DATE(w.created_date)) AS created_dt,
    MAX(DATE(w.updated_date)) AS updated_dt
  FROM openalex.mid.work w
  JOIN openalex.mid.work_extra_ids x ON w.paper_id = x.paper_id
  WHERE x.attribute_type = 2 -- Corresponds to pmid
  GROUP BY x.attribute_value
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING paper_ids AS source
  ON LOWER(TRIM(target.pmid)) = LOWER(TRIM(source.pmid))
  AND target.paper_id IS NULL -- Only match rows that need a paper_id
WHEN MATCHED THEN
UPDATE SET
  target.paper_id = source.paper_id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.created_dt),
  target.openalex_updated_dt = source.updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match using `mid.work.arxiv_id`

-- COMMAND ----------

WITH paper_ids AS (
  SELECT
    w.arxiv_id,
    MIN(w.paper_id) AS paper_id,      -- Choose the smallest legacy ID as the canonical one
    MIN(DATE(w.created_date)) AS created_dt,
    MAX(DATE(w.updated_date)) AS updated_dt
  FROM openalex.mid.work w
  WHERE w.arxiv_id IS NOT NULL
  GROUP BY w.arxiv_id
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING paper_ids AS source
  ON LOWER(TRIM(target.arxiv)) = LOWER(TRIM(source.arxiv_id))
  AND target.paper_id IS NULL -- Only match rows that need a paper_id
WHEN MATCHED THEN
UPDATE SET
  target.paper_id = source.paper_id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.created_dt),
  target.openalex_updated_dt = source.updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match using `CONCAT(mid.work.normalize_title, '_', mid.affiliations.match_title)` 

-- COMMAND ----------

-- Build paper_ids one-step (already lower-cased / trimmed)
WITH affiliation_authors AS (
  SELECT paper_id, MAX(COALESCE(match_author, '')) as author_key
  FROM openalex.mid.affiliation
  WHERE author_sequence_number = 1
  GROUP BY paper_id
),
paper_ids AS (
  SELECT      
      MIN(w.paper_id) AS paper_id, -- choose smallest legacy id
      CONCAT(w.normalized_title, '_', aa.author_key) as title_author,
      MIN(DATE(w.created_date)) AS created_dt,
      MAX(DATE(w.updated_date)) AS updated_dt
  FROM openalex.mid.work w
  JOIN affiliation_authors aa USING (paper_id)
  WHERE w.arxiv_id IS NULL
    AND (w.doi IS NULL OR w.doi = '')
    AND LENGTH(w.normalized_title) > 0
  GROUP BY title_author
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.work_id_map') AS target
USING paper_ids AS source
  ON target.title_author = source.title_author
  AND target.paper_id IS NULL
WHEN MATCHED THEN
UPDATE SET
  target.paper_id = source.paper_id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.created_dt),
  target.openalex_updated_dt = source.updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Set `locations_mapped.work_id = work_id_map.paper_id` when matched

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `DOI` match

-- COMMAND ----------

-- Merge on DOI matches
WITH ids AS (
  SELECT DISTINCT
    doi,
    MIN(paper_id) AS paper_id,
    MIN(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NOT NULL
    AND doi IS NOT NULL
  GROUP BY doi
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.doi = source.doi
  AND (target.work_id IS NULL OR target.work_id > source.paper_id)
WHEN MATCHED
THEN UPDATE SET 
  target.work_id = source.paper_id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match

-- COMMAND ----------

 WITH ids AS (
  SELECT DISTINCT
    pmid as pmid,
    MIN(paper_id) AS paper_id,
    MIN(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NOT NULL
    AND pmid IS NOT NULL
  GROUP BY pmid
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source
  ON target.merge_key.pmid = source.pmid
  AND (target.work_id IS NULL OR target.work_id > source.paper_id)
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.paper_id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match

-- COMMAND ----------

-- Merge on ARXIV matches
WITH ids AS (
  SELECT DISTINCT
    arxiv,
    MIN(paper_id) AS paper_id,
    MIN(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NOT NULL
    AND arxiv IS NOT NULL
  GROUP BY arxiv
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.arxiv = source.arxiv
  AND (target.work_id IS NULL OR target.work_id > source.paper_id)
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.paper_id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match

-- COMMAND ----------

WITH ids AS (
  SELECT DISTINCT
    title_author,
    MIN(paper_id) AS paper_id,
    MIN(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NOT NULL
    AND (doi IS NULL AND pmid IS NULL AND arxiv IS NULL)
    AND title_author IS NOT NULL
  GROUP BY title_author
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.title_author = source.title_author
  AND (target.work_id IS NULL OR target.work_id > source.paper_id)
  AND LENGTH(source.title_author) > 20
WHEN MATCHED THEN UPDATE SET
  target.work_id = source.paper_id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Populate MINTED `locations_mapped.work_id` from `works_id_map` WHERE work_id is NULL
-- MAGIC This is not necessarily minting only - `MIN(id)` is used which may result in a match to earlier `work_id`

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `DOI` match

-- COMMAND ----------

WITH ids AS (
  SELECT
    doi as doi,
    MIN(id) AS id,
    MIN(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NULL
    AND doi IS NOT NULL
  GROUP BY doi
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.doi = source.doi
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match

-- COMMAND ----------

-- Merge on PMID matches
WITH ids AS (
  SELECT DISTINCT
    pmid as pmid,
    MIN(id) AS id,
    MIN(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NULL
    AND pmid IS NOT NULL
  GROUP BY pmid
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.pmid = source.pmid
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match

-- COMMAND ----------

-- Merge on ARXIV matches
WITH ids AS (
  SELECT DISTINCT
    arxiv as arxiv,
    MIN(id) AS id,
    MIN(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NULL
    AND arxiv IS NOT NULL
  GROUP BY arxiv
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.arxiv = source.arxiv
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match

-- COMMAND ----------

-- Merge on TITLE_AUTHOR matches
WITH ids AS (
  SELECT DISTINCT
    title_author,
    MIN(id) AS id,
    MIN(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.work_id_map')
  WHERE paper_id IS NULL
    AND (doi IS NULL AND pmid IS NULL AND arxiv IS NULL)
    AND title_author IS NOT NULL
  GROUP BY title_author
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.title_author = source.title_author
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = LEAST(target.openalex_created_dt, source.openalex_created_dt),
  target.openalex_updated_dt = source.openalex_updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Insert legacy `paper_id`'s based on mag id

-- COMMAND ----------

WITH mag_walden_works AS (
  SELECT
    get(filter(ids, x -> x.namespace = 'mag').id, 0) AS legacy_work_id,
    MAX(get(filter(ids, x -> x.namespace = 'mag').id, 0)) OVER (
      PARTITION BY work_id
    ) AS assigned_work_id,
    work_id
  FROM identifier('openalex' || :env_suffix || '.works.locations_mapped')
  WHERE provenance = 'mag'
),
updated_mag_walden_works AS (
  SELECT
    work_id AS current_work_id,
    COALESCE(legacy_work_id, assigned_work_id) AS new_work_id
  FROM mag_walden_works
  WHERE COALESCE(legacy_work_id, assigned_work_id) IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY work_id
    ORDER BY COALESCE(legacy_work_id, assigned_work_id)
  ) = 1
)

MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING updated_mag_walden_works AS source
ON target.work_id = source.current_work_id
WHEN MATCHED AND target.work_id > 6600000000 THEN -- only overwrite assigned work ids - not legacy
UPDATE SET
  target.work_id = source.new_work_id;


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Insert legacy `paper_id`'s based on pmh_id

-- COMMAND ----------

WITH pmh_mapping AS (
  -- select the lowest work_id (since we have multiple PMH IDs for the same work and a legacy work_id 
  -- is always lower than a newly minted work_id, which increments starting at 6600000001).
  SELECT LOWER(pmh_id) AS pmh_id, MIN(work_id) AS legacy_work_id
  FROM openalex.works_poc.work_id_to_pmh_id_final
  GROUP BY pmh_id
),
repo_walden_works AS (
  SELECT *,
         CASE WHEN provenance IN ('repo', 'repo_backfill') THEN LOWER(native_id) END AS pmh_id_walden
  FROM identifier('openalex' || :env_suffix || '.works.locations_mapped')
  WHERE provenance IN ('repo', 'repo_backfill') AND work_id > 6600000000
),
updated_repo_walden_works AS ( --partition to get MIN legacy_work_id if multiple per work_id exist
  SELECT
    r.work_id AS current_work_id,
    m.legacy_work_id
  FROM repo_walden_works r
  LEFT JOIN pmh_mapping m ON r.pmh_id_walden = m.pmh_id
  WHERE m.legacy_work_id IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY r.work_id
    ORDER BY m.legacy_work_id ASC
  ) = 1
)

MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING updated_repo_walden_works AS source
ON target.work_id = source.current_work_id
WHEN MATCHED THEN UPDATE SET
  target.work_id = source.legacy_work_id;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Curation - new locations

-- COMMAND ----------

WITH curation_locations AS (
  SELECT
    -- Extract work_id and convert from OpenAlex URL to numeric ID
    CASE 
      WHEN get_json_object(property_value, '$.work_id') LIKE 'https://openalex.org/W%'
      THEN CAST(SUBSTRING(get_json_object(property_value, '$.work_id'), 23) AS BIGINT)
      ELSE NULL
    END AS work_id,
    
    NULL as work_id_source,
    TRY_TO_TIMESTAMP(moderated_date) AS moderated_ts,
    
    -- Create merge_key structure with minimal data
    STRUCT(
      NULL as doi,
      NULL as pmid, 
      NULL as arxiv,
      CASE 
        WHEN get_json_object(property_value, '$.title') IS NOT NULL 
        THEN CONCAT(
          get_json_object(property_value, '$.title'), 
          '_', 
          CAST(
            CASE 
              WHEN get_json_object(property_value, '$.work_id') LIKE 'https://openalex.org/W%'
              THEN SUBSTRING(get_json_object(property_value, '$.work_id'), 23)
              ELSE id
            END AS STRING
          )
        )
        ELSE NULL 
      END as title_author
    ) as merge_key,
    
    NULL as key_lineage,
    'curation' as provenance,
    SPLIT(entity_id, ':')[1] as native_id,
    'openalex_curation' as native_id_namespace,
    get_json_object(property_value, '$.title') as title,
    NULL as normalized_title,
    CAST(NULL AS ARRAY<STRUCT<given: STRING, family: STRING, name: STRING, orcid: STRING, affiliations: ARRAY<STRUCT<name: STRING, department: STRING, ror_id: STRING>>, is_corresponding: BOOLEAN, author_key: STRING>>) as authors,
    CAST(NULL AS ARRAY<STRUCT<id: STRING, namespace: STRING, relationship: STRING>>) as ids,
    NULL as type,
    'submittedVersion' as version,
    get_json_object(property_value, '$.license') as license,
    NULL as language,
    NULL as published_date,
    NULL as created_date,
    CAST(moderated_ts AS DATE) as updated_date,
    NULL as issue,
    NULL as volume,
    NULL as first_page,
    NULL as last_page,
    NULL as is_retracted,
    NULL as abstract,
    NULL as source_name,
    NULL as publisher,
    CAST(NULL AS ARRAY<STRUCT<doi: STRING, ror: STRING, name: STRING, awards: ARRAY<STRING>>>) as funders,
    CAST(NULL AS ARRAY<STRUCT<doi: STRING, pmid: STRING, arxiv: STRING, title: STRING, authors: STRING, year: STRING, raw: STRING>>) as references,
    CAST(NULL AS ARRAY<STRUCT<url: STRING, content_type: STRING>>) as urls,
    get_json_object(property_value, '$.pdf_url') as pdf_url,
    get_json_object(property_value, '$.landing_page_url') as landing_page_url,
    NULL as pdf_s3_id,
    NULL as grobid_s3_id,
    NULL as mesh,
    CAST(get_json_object(property_value, '$.is_oa') AS BOOLEAN) as is_oa,
    NULL as is_oa_source,
    NULL as referenced_works_count,
    CAST(NULL AS ARRAY<BIGINT>) as referenced_works,
    NULL as abstract_inverted_index,
    NULL as authors_exist,
    NULL as affiliations_exist,
    NULL as is_corresponding_exists,
    NULL as best_doi,
    
    -- Extract source_id and convert from OpenAlex URL to numeric ID
    CASE 
      WHEN get_json_object(property_value, '$.source_id') LIKE 'https://openalex.org/S%'
      THEN CAST(SUBSTRING(get_json_object(property_value, '$.source_id'), 23) AS BIGINT)
      ELSE NULL
    END AS source_id,
    
    CAST(moderated_ts AS DATE)  as openalex_created_dt,
    moderated_ts as openalex_updated_dt
    
  FROM openalex.curations.approved_curations
  WHERE entity = 'locations'
    AND status = 'approved'
    AND create_new = true
)

MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING curation_locations AS source
ON target.native_id = source.native_id 
   AND target.native_id_namespace = source.native_id_namespace
   AND target.provenance = source.provenance

WHEN MATCHED AND (
   (source.title            IS NOT NULL AND source.title            IS DISTINCT FROM target.title) OR
   (source.pdf_url          IS NOT NULL AND source.pdf_url          IS DISTINCT FROM target.pdf_url) OR
   (source.landing_page_url IS NOT NULL AND source.landing_page_url IS DISTINCT FROM target.landing_page_url) OR
   (source.license          IS NOT NULL AND source.license          IS DISTINCT FROM target.license) OR
   (source.is_oa            IS NOT NULL AND source.is_oa            IS DISTINCT FROM target.is_oa) OR
   (source.source_id        IS NOT NULL AND source.source_id        IS DISTINCT FROM target.source_id)
)
THEN UPDATE SET
  target.title               = COALESCE(source.title,            target.title),
  target.pdf_url             = COALESCE(source.pdf_url,          target.pdf_url),
  target.landing_page_url    = COALESCE(source.landing_page_url, target.landing_page_url),
  target.license             = COALESCE(source.license,          target.license),
  target.is_oa               = COALESCE(source.is_oa,            target.is_oa),
  target.source_id           = COALESCE(source.source_id,        target.source_id),
  target.updated_date        = CAST(source.openalex_updated_dt AS DATE),
  target.openalex_updated_dt = source.openalex_updated_dt

WHEN NOT MATCHED THEN INSERT (
    work_id,
    work_id_source,
    merge_key,
    key_lineage,
    provenance,
    native_id,
    native_id_namespace,
    title,
    normalized_title,
    authors,
    ids,
    type,
    version,
    license,
    language,
    published_date,
    created_date,
    updated_date,
    issue,
    volume,
    first_page,
    last_page,
    is_retracted,
    abstract,
    source_name,
    publisher,
    funders,
    references,
    urls,
    pdf_url,
    landing_page_url,
    pdf_s3_id,
    grobid_s3_id,
    mesh,
    is_oa,
    is_oa_source,
    referenced_works_count,
    referenced_works,
    abstract_inverted_index,
    authors_exist,
    affiliations_exist,
    is_corresponding_exists,
    best_doi,
    source_id,
    openalex_created_dt,
    openalex_updated_dt
) VALUES (
    source.work_id,
    source.work_id_source,
    source.merge_key,
    source.key_lineage,
    source.provenance,
    source.native_id,
    source.native_id_namespace,
    source.title,
    source.normalized_title,
    source.authors,
    source.ids,
    source.type,
    source.version,
    source.license,
    source.language,
    source.published_date,
    source.created_date,
    source.updated_date,
    source.issue,
    source.volume,
    source.first_page,
    source.last_page,
    source.is_retracted,
    source.abstract,
    source.source_name,
    source.publisher,
    source.funders,
    source.references,
    source.urls,
    source.pdf_url,
    source.landing_page_url,
    source.pdf_s3_id,
    source.grobid_s3_id,
    source.mesh,
    source.is_oa,
    source.is_oa_source,
    source.referenced_works_count,
    source.referenced_works,
    source.abstract_inverted_index,
    source.authors_exist,
    source.affiliations_exist,
    source.is_corresponding_exists,
    source.best_doi,
    source.source_id,
    source.openalex_created_dt,
    source.openalex_updated_dt
);

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Curation - location overrides

-- COMMAND ----------

-- 1) Latest approved curation per (entity_id, property)
WITH latest_per_field AS (
  SELECT
    split(entity_id, ':')[1] AS native_id,
    split(entity_id, ':')[0] AS native_id_namespace,
    property,
    NULLIF(TRIM(property_value), 'null') AS property_value,
    TRY_TO_TIMESTAMP(moderated_date) AS moderated_ts,
    ROW_NUMBER() OVER (
      PARTITION BY entity_id, property
      ORDER BY TRY_TO_TIMESTAMP(moderated_date) DESC NULLS LAST, id DESC
    ) AS rn
  FROM openalex.curations.approved_curations
  WHERE entity = 'locations'
    AND status = 'approved'
    AND create_new = false
),
dedup AS (
  SELECT native_id, native_id_namespace, property, property_value, moderated_ts
  FROM latest_per_field
  WHERE rn = 1
),

-- 2) Pivot with a value and an "apply" flag per field, so we can update values to null
curation_overrides_pivoted AS (
  SELECT
    native_id,
    native_id_namespace,

    -- values
    MAX(CASE WHEN property='title'             THEN property_value END)                                  AS title_val,
    MAX(CASE WHEN property='pdf_url'           THEN property_value END)                                  AS pdf_url_val,
    MAX(CASE WHEN property='landing_page_url'  THEN property_value END)                                  AS landing_page_url_val,
    MAX(CASE WHEN property='license'           THEN LOWER(property_value) END)                           AS license_val,
    MAX(CASE WHEN property='is_oa'             THEN CAST(LOWER(property_value) IN ('true','t','1','yes') AS BOOLEAN) END) AS is_oa_val,

    MAX(CASE WHEN property='type'              THEN LOWER(property_value) END)                           AS type_val,
    MAX(CASE WHEN property='version'           THEN property_value END)                                   AS version_val,
    MAX(CASE WHEN property='language'          THEN LOWER(property_value) END)                            AS language_val,
    MAX(CASE WHEN property='issue'             THEN property_value END)                                   AS issue_val,
    MAX(CASE WHEN property='volume'            THEN property_value END)                                   AS volume_val,
    MAX(CASE WHEN property='first_page'        THEN property_value END)                                   AS first_page_val,
    MAX(CASE WHEN property='last_page'         THEN property_value END)                                   AS last_page_val,
    MAX(CASE WHEN property='is_retracted'      THEN CAST(LOWER(property_value) IN ('true','t','1','yes') AS BOOLEAN) END) AS is_retracted_val,

    -- apply flags (1 if curator set the field, even if to NULL)
    MAX(CASE WHEN property='title'             THEN 1 ELSE 0 END) AS title_apply,
    MAX(CASE WHEN property='pdf_url'           THEN 1 ELSE 0 END) AS pdf_url_apply,
    MAX(CASE WHEN property='landing_page_url'  THEN 1 ELSE 0 END) AS landing_page_url_apply,
    MAX(CASE WHEN property='license'           THEN 1 ELSE 0 END) AS license_apply,
    MAX(CASE WHEN property='is_oa'             THEN 1 ELSE 0 END) AS is_oa_apply,
    MAX(CASE WHEN property='type'              THEN 1 ELSE 0 END) AS type_apply,
    MAX(CASE WHEN property='version'           THEN 1 ELSE 0 END) AS version_apply,
    MAX(CASE WHEN property='language'          THEN 1 ELSE 0 END) AS language_apply,
    MAX(CASE WHEN property='issue'             THEN 1 ELSE 0 END) AS issue_apply,
    MAX(CASE WHEN property='volume'            THEN 1 ELSE 0 END) AS volume_apply,
    MAX(CASE WHEN property='first_page'        THEN 1 ELSE 0 END) AS first_page_apply,
    MAX(CASE WHEN property='last_page'         THEN 1 ELSE 0 END) AS last_page_apply,
    MAX(CASE WHEN property='is_retracted'      THEN 1 ELSE 0 END) AS is_retracted_apply,

    MAX(moderated_ts) AS latest_moderated_dt
  FROM dedup
  GROUP BY native_id, native_id_namespace
)

-- 3) MERGE: use apply flags, allow NULL values, and only update on real changes
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING curation_overrides_pivoted AS source
ON  target.native_id = source.native_id
AND target.native_id_namespace = source.native_id_namespace

WHEN MATCHED AND (
  (source.title_apply            = 1 AND source.title_val            IS DISTINCT FROM target.title)            OR
  (source.pdf_url_apply          = 1 AND source.pdf_url_val          IS DISTINCT FROM target.pdf_url)          OR
  (source.pdf_url_apply = 1 AND source.pdf_url_val IS NULL AND
     EXISTS(target.urls, x -> lower(x.content_type) IN ('pdf','application/pdf'))
  ) OR
  (source.landing_page_url_apply = 1 AND source.landing_page_url_val IS DISTINCT FROM target.landing_page_url) OR
  (source.license_apply          = 1 AND source.license_val          IS DISTINCT FROM target.license)          OR
  (source.is_oa_apply            = 1 AND source.is_oa_val            IS DISTINCT FROM target.is_oa)            OR
  (source.type_apply             = 1 AND source.type_val             IS DISTINCT FROM target.`type`)           OR
  (source.version_apply          = 1 AND source.version_val          IS DISTINCT FROM target.version)          OR
  (source.language_apply         = 1 AND source.language_val         IS DISTINCT FROM target.language)         OR
  (source.issue_apply            = 1 AND source.issue_val            IS DISTINCT FROM target.issue)            OR
  (source.volume_apply           = 1 AND source.volume_val           IS DISTINCT FROM target.volume)           OR
  (source.first_page_apply       = 1 AND source.first_page_val       IS DISTINCT FROM target.first_page)       OR
  (source.last_page_apply        = 1 AND source.last_page_val        IS DISTINCT FROM target.last_page)        OR
  (source.is_retracted_apply     = 1 AND source.is_retracted_val     IS DISTINCT FROM target.is_retracted)
)
THEN UPDATE SET
  target.title            = CASE WHEN source.title_apply            = 1 THEN source.title_val            ELSE target.title            END,
  target.pdf_url          = CASE WHEN source.pdf_url_apply          = 1 THEN source.pdf_url_val          ELSE target.pdf_url          END,
  -- when pdf_url is set to null we need to remove pdf urls from the urls array too, or they will be picked up in works. CDM
  target.urls = CASE
                  WHEN source.pdf_url_apply = 1 AND source.pdf_url_val IS NULL THEN
                    CASE WHEN target.urls IS NULL THEN NULL
                         ELSE FILTER(
                                target.urls,
                                x -> lower(x.content_type) NOT IN ('pdf','application/pdf')
                              )
                    END
                  ELSE target.urls
                END,
  target.landing_page_url = CASE WHEN source.landing_page_url_apply = 1 THEN source.landing_page_url_val ELSE target.landing_page_url END,
  target.license          = CASE WHEN source.license_apply          = 1 THEN source.license_val          ELSE target.license          END,
  target.is_oa            = CASE WHEN source.is_oa_apply            = 1 THEN source.is_oa_val            ELSE target.is_oa            END,
  target.`type`           = CASE WHEN source.type_apply             = 1 THEN source.type_val             ELSE target.`type`           END,
  target.version          = CASE WHEN source.version_apply          = 1 THEN source.version_val          ELSE target.version          END,
  target.language         = CASE WHEN source.language_apply         = 1 THEN source.language_val         ELSE target.language         END,
  target.issue            = CASE WHEN source.issue_apply            = 1 THEN source.issue_val            ELSE target.issue            END,
  target.volume           = CASE WHEN source.volume_apply           = 1 THEN source.volume_val           ELSE target.volume           END,
  target.first_page       = CASE WHEN source.first_page_apply       = 1 THEN source.first_page_val       ELSE target.first_page       END,
  target.last_page        = CASE WHEN source.last_page_apply        = 1 THEN source.last_page_val        ELSE target.last_page        END,
  target.is_retracted     = CASE WHEN source.is_retracted_apply     = 1 THEN source.is_retracted_val     ELSE target.is_retracted     END,

  target.openalex_updated_dt = source.latest_moderated_dt
;

-- COMMAND ----------

-- MAGIC %md ## Create `referenced_works` ids from `referenced_works` table
-- MAGIC - Data comes from an exploded table that is populated using matching and parsing of dois, titles and authors

-- COMMAND ----------

WITH aggregated_refs AS (
  SELECT
    citing_work_id,
    TRANSFORM(
      SORT_ARRAY(COLLECT_LIST(STRUCT(ref_ind, cited_work_id))),
      x -> x.cited_work_id
    ) AS referenced_works
  FROM openalex.works.work_references
  WHERE cited_work_id IS NOT NULL
  GROUP BY citing_work_id
)
MERGE INTO openalex.works.locations_mapped AS target
USING aggregated_refs AS source
ON target.work_id = source.citing_work_id
WHEN MATCHED AND (
  target.referenced_works IS DISTINCT FROM source.referenced_works OR
  target.referenced_works_count IS DISTINCT FROM SIZE(source.referenced_works)
)
THEN UPDATE SET
  target.referenced_works = source.referenced_works,
  target.referenced_works_count = SIZE(source.referenced_works);

-- COMMAND ----------

SELECT format_number(COUNT(*), 0) as row_count
FROM openalex.works.locations_mapped --618,448,502 - July 16th, 618,777,313 - July 17th
