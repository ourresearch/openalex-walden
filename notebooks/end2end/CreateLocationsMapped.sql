-- Databricks notebook source
-- MAGIC %md
-- MAGIC ### Create `locations_mapped` and `id_map` tables IF THEY DO NOT EXIST
-- MAGIC No re-creation and full idempotency are new features.

-- COMMAND ----------

CREATE TABLE IF NOT EXISTS identifier('openalex' || :env_suffix || '.works.locations_mapped') (
  work_id BIGINT,
  work_id_source STRING,
  merge_key STRUCT<doi: STRING, pmid: STRING, arxiv: STRING, title_author: STRING>,
  key_lineage STRING,
  provenance STRING,
  native_id STRING,
  --true_native_id STRING,
  native_id_namespace STRING,
  title STRING,
  normalized_title STRING,
  authors ARRAY<STRUCT<given: STRING, family: STRING, name: STRING, orcid: STRING, affiliations: ARRAY<STRUCT<name: STRING, department: STRING, ror_id: STRING>>, is_corresponding: BOOLEAN, author_key: STRING>>,
  ids ARRAY<STRUCT<id: STRING, namespace: STRING, relationship: STRING>>,
  type STRING,
  version STRING,
  license STRING,
  language STRING,
  published_date DATE,
  created_date DATE,
  updated_date DATE,
  issue STRING,
  volume STRING,
  first_page STRING,
  last_page STRING,
  is_retracted BOOLEAN,
  abstract STRING,
  source_name STRING,
  publisher STRING,
  funders ARRAY<STRUCT<doi: STRING, ror: STRING, name: STRING, awards: ARRAY<STRING>>>,
  references ARRAY<STRUCT<doi: STRING, pmid: STRING, arxiv: STRING, title: STRING, authors: STRING, year: STRING, raw: STRING>>,
  urls ARRAY<STRUCT<url: STRING, content_type: STRING>>,
  pdf_url STRING,
  landing_page_url STRING,
  pdf_s3_id STRING,
  grobid_s3_id STRING,
  mesh STRING,
  is_oa BOOLEAN,
  is_oa_source BOOLEAN,
  referenced_works_count INT,
  referenced_works ARRAY<BIGINT>,
  abstract_inverted_index STRING,
  authors_exist BOOLEAN,
  affiliations_exist BOOLEAN,
  is_corresponding_exists BOOLEAN,
  best_doi STRING,
  source_id BIGINT,
  openalex_created_dt DATE,
  openalex_updated_dt TIMESTAMP)
USING delta
CLUSTER BY (merge_key.doi, merge_key.pmid, merge_key.arxiv, merge_key.title_author)
TBLPROPERTIES (
  'delta.checkpoint.writeStatsAsJson' = 'false',
  'delta.checkpoint.writeStatsAsStruct' = 'true',
  'delta.enableDeletionVectors' = 'true',
  'delta.feature.deletionVectors' = 'supported',
  'delta.feature.rowTracking' = 'supported',
  'delta.feature.v2Checkpoint' = 'supported');

CREATE TABLE IF NOT EXISTS identifier('openalex' || :env_suffix || '.works.id_map') (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 6600000001 INCREMENT BY 1),
  paper_id STRING,
  merge_key STRUCT<doi: STRING, pmid: STRING, arxiv: STRING, title_author: STRING>,
  doi STRING,
  pmid STRING,
  arxiv STRING,
  title_author STRING,
  openalex_created_dt DATE,
  openalex_updated_dt TIMESTAMP
)
CLUSTER BY (merge_key.doi, merge_key.pmid, merge_key.arxiv, merge_key.title_author)
TBLPROPERTIES (
  'delta.checkpoint.writeStatsAsJson' = 'false',
  'delta.checkpoint.writeStatsAsStruct' = 'true',
  'delta.enableDeletionVectors' = 'true',
  'delta.feature.deletionVectors' = 'supported',
  'delta.feature.rowTracking' = 'supported',
  'delta.feature.v2Checkpoint' = 'supported');  

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### Merge deduplicated records from `locations_w_sources` into `locations_mapped`
-- MAGIC Merge deduplicated records from `locations_w_sources` into `locations_mapped`, inserting rows with `work_id = NULL` and updating others.

-- COMMAND ----------

-- Merge DOI's into locations_mapped 
WITH counted_works AS (
    SELECT 
        *,
        ROW_NUMBER() OVER(PARTITION BY merge_key, native_id, native_id_namespace, provenance ORDER BY updated_date DESC) AS rwcnt
    FROM identifier('openalex' || :env_suffix || '.works.locations_w_sources')
),
distinct_works AS (
    SELECT *
    FROM counted_works
    WHERE rwcnt = 1
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING distinct_works AS source
ON target.merge_key IS NOT DISTINCT FROM source.merge_key
    AND target.native_id IS NOT DISTINCT FROM source.native_id
    AND target.native_id_namespace IS NOT DISTINCT FROM source.native_id_namespace
    AND target.provenance IS NOT DISTINCT FROM source.provenance
    -- Ensure merge_key has at least one non-null field (avoid matching {null, null, null, (null or empty)})
    AND (
      target.merge_key.doi IS NOT NULL OR
      target.merge_key.pmid IS NOT NULL OR 
      target.merge_key.arxiv IS NOT NULL OR
      target.merge_key.title_author IS NOT NULL OR
      target.merge_key.title_author <> ''
    )
WHEN MATCHED 
AND (
    (target.provenance <> source.provenance                       AND target.provenance IS NOT NULL) OR
    (target.native_id <> source.native_id                         AND target.native_id IS NOT NULL) OR
    --(target.true_native_id <> source.true_native_id               AND target.true_native_id IS NOT NULL) OR
    (target.native_id_namespace <> source.native_id_namespace     AND target.native_id_namespace IS NOT NULL) OR
    (target.title <> source.title                                 AND target.title IS NOT NULL) OR
    (target.normalized_title <> source.normalized_title           AND target.normalized_title IS NOT NULL) OR
    
    (target.type <> source.type                                   AND target.type IS NOT NULL) OR
    (target.version <> source.version                             AND target.version IS NOT NULL) OR
    (target.license <> source.license                             AND target.license IS NOT NULL) OR
    (target.language <> source.language                           AND target.language IS NOT NULL) OR
    (target.published_date <> source.published_date               AND target.published_date IS NOT NULL) OR
    (target.created_date <> source.created_date                   AND target.created_date IS NOT NULL) OR
    -- (target.updated_date <> source.updated_date                   AND target.updated_date IS NOT NULL) OR
    (target.issue <> source.issue                                 AND target.issue IS NOT NULL) OR
    (target.volume <> source.volume                               AND target.volume IS NOT NULL) OR
    (target.first_page <> source.first_page                       AND target.first_page IS NOT NULL) OR
    (target.last_page <> source.last_page                         AND target.last_page IS NOT NULL) OR
    (target.is_retracted <> source.is_retracted                   AND target.is_retracted IS NOT NULL) OR
    (target.abstract <> source.abstract                           AND target.abstract IS NOT NULL) OR
    (target.source_name <> source.source_name                     AND target.source_name IS NOT NULL) OR
    (target.publisher <> source.publisher                         AND target.publisher IS NOT NULL) OR
    (target.pdf_url <> source.pdf_url                             AND target.pdf_url IS NOT NULL) OR
    (target.landing_page_url <> source.landing_page_url           AND target.landing_page_url IS NOT NULL) OR
    (target.pdf_s3_id <> source.pdf_s3_id                         AND target.pdf_s3_id IS NOT NULL) OR
    (target.grobid_s3_id <> source.grobid_s3_id                   AND target.grobid_s3_id IS NOT NULL) OR
    (target.mesh <> source.mesh                                   AND target.mesh IS NOT NULL) OR
    (target.is_oa <> source.is_oa                                 AND target.is_oa IS NOT NULL) OR
    (target.is_oa_source <> source.is_oa_source                   AND target.is_oa_source IS NOT NULL) OR
    -- (target.abstract_inverted_index <> source.abstract_inverted_index  AND target.abstract_inverted_index IS NOT NULL) OR
    (target.authors_exist <> source.authors_exist                 AND target.authors_exist IS NOT NULL) OR
    (target.affiliations_exist <> source.affiliations_exist       AND target.affiliations_exist IS NOT NULL) OR
    (target.is_corresponding_exists <> source.is_corresponding_exists AND target.is_corresponding_exists IS NOT NULL) OR
    (target.best_doi <> source.best_doi                           AND target.best_doi IS NOT NULL) OR
    (target.source_id <> source.source_id                         AND target.source_id IS NOT NULL)
)  
THEN UPDATE SET 
    target.provenance = source.provenance,
    target.native_id = source.native_id,
    --target.true_native_id = source.true_native_id,
    target.native_id_namespace = source.native_id_namespace,
    target.title = source.title,
    target.normalized_title = source.normalized_title,
    target.authors = array_union(coalesce(source.authors,array()),coalesce(target.authors,array())),
    target.ids = array_union(coalesce(source.ids,array()),coalesce(target.ids,array())),
    target.type = source.type,
    target.version = source.version,
    target.license = source.license,
    target.language = source.language,
    target.published_date = source.published_date,
    target.created_date = source.created_date,
    target.updated_date = source.updated_date,
    target.issue = source.issue,
    target.volume = source.volume,
    target.first_page = source.first_page,
    target.last_page = source.last_page,
    target.is_retracted = source.is_retracted,
    target.abstract = source.abstract,
    target.source_name = source.source_name,
    target.publisher = source.publisher,
    target.funders = array_union(coalesce(source.funders,array()),coalesce(target.funders,array())),
    target.references = source.references,
    target.urls = array_union(coalesce(source.urls,array()),coalesce(target.urls,array())),
    target.pdf_url = source.pdf_url,
    target.landing_page_url = source.landing_page_url,
    target.pdf_s3_id = source.pdf_s3_id,
    target.grobid_s3_id = source.grobid_s3_id,
    target.mesh = source.mesh,
    target.is_oa = source.is_oa,
    target.is_oa_source = source.is_oa_source,
    target.abstract_inverted_index = source.abstract_inverted_index,
    target.authors_exist = source.authors_exist,
    target.affiliations_exist = source.affiliations_exist,
    target.is_corresponding_exists = source.is_corresponding_exists,
    target.best_doi = source.best_doi,
    target.source_id = source.source_id,
    target.openalex_updated_dt = current_timestamp()
WHEN NOT MATCHED THEN INSERT (
    work_id,
    merge_key,
    provenance,
    native_id,
    --true_native_id,
    native_id_namespace,
    title,
    normalized_title,
    authors,
    ids,
    type,
    version,
    license,
    language,
    published_date,
    created_date,
    updated_date,
    issue,
    volume,
    first_page,
    last_page,
    is_retracted,
    abstract,
    source_name,
    publisher,
    funders,
    references,
    urls,
    pdf_url,
    landing_page_url,
    pdf_s3_id,
    grobid_s3_id,
    mesh,
    is_oa,
    is_oa_source,
    referenced_works_count,
    referenced_works,
    abstract_inverted_index,
    authors_exist,
    affiliations_exist,
    is_corresponding_exists,
    best_doi,
    source_id,
    openalex_created_dt,
    openalex_updated_dt
) VALUES (
    null,
    source.merge_key,
    source.provenance,
    source.native_id,
    --source.true_native_id,
    source.native_id_namespace,
    source.title,
    source.normalized_title,
    source.authors,
    source.ids,
    source.type,
    source.version,
    source.license,
    source.language,
    source.published_date,
    source.created_date,
    source.updated_date,
    source.issue,
    source.volume,
    source.first_page,
    source.last_page,
    source.is_retracted,
    source.abstract,
    source.source_name,
    source.publisher,
    source.funders,
    source.references,
    source.urls,
    source.pdf_url,
    source.landing_page_url,
    source.pdf_s3_id,
    source.grobid_s3_id,
    source.mesh,
    source.is_oa,
    source.is_oa_source,
    NULL, --referenced_works_count
    NULL, --referenced_works is calculated from self-join
    source.abstract_inverted_index,
    source.authors_exist,
    source.affiliations_exist,
    source.is_corresponding_exists,
    source.best_doi,
    source.source_id,
    current_date(),
    current_timestamp()
);

-- COMMAND ----------

ALTER TABLE openalex.works.id_map CLUSTER BY NONE;
OPTIMIZE openalex.works.id_map
ZORDER BY (merge_key.doi, merge_key.pmid, merge_key.arxiv, merge_key.title_author);

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Merge into `id_map`
-- MAGIC Extract unmapped merge_keys from `locations_mapped` where `work_id IS NULL`, and merge them into `id_map` (insert new merge_keys).
-- MAGIC Inserted records will contain newly minted `work_id` values (they won't necessarily make it into `locations_mapped`).

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### Create merge candidates from `locations_mapped` where `work_id IS NULL`

-- COMMAND ----------

CREATE OR REPLACE TABLE identifier('openalex' || :env_suffix || '.works.id_map_candidate_merge_keys')
CLUSTER BY (doi, pmid, arxiv, title_author)
AS
SELECT
  merge_key.doi           AS doi,
  merge_key.pmid          AS pmid,
  merge_key.arxiv         AS arxiv,
  merge_key.title_author  AS title_author,
  merge_key,
  (
    IF(merge_key.doi IS NOT NULL, 4, 0) +
    IF(merge_key.pmid IS NOT NULL, 3, 0) +
    IF(merge_key.arxiv IS NOT NULL, 2, 0) +
    IF(merge_key.title_author IS NOT NULL, 1, 0)
  ) AS key_score,
  MIN(openalex_created_dt) AS openalex_created_dt,
  MAX(openalex_updated_dt) AS openalex_updated_dt
FROM identifier('openalex' || :env_suffix || '.works.locations_mapped')
WHERE work_id IS NULL
  AND openalex_updated_dt > COALESCE(
    (SELECT MAX(openalex_updated_dt)
     FROM identifier('openalex' || :env_suffix || '.works.id_map')),
    '1970-01-01'
  )
GROUP BY doi, pmid, arxiv, title_author, merge_key


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `DOI` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.id_map') AS target
USING (
  SELECT *
  FROM identifier('openalex' || :env_suffix || '.works.id_map_candidate_merge_keys')
  WHERE doi IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY doi
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON target.doi = source.doi
WHEN MATCHED THEN UPDATE SET
  target.merge_key.doi = COALESCE(source.doi, target.merge_key.doi),
  target.merge_key.pmid = COALESCE(source.pmid, target.merge_key.pmid),
  target.merge_key.arxiv = COALESCE(source.arxiv, target.merge_key.arxiv),
  target.merge_key.title_author = COALESCE(source.title_author, target.merge_key.title_author),
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'doi'
WHEN NOT MATCHED THEN INSERT (
  merge_key, doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  STRUCT(source.doi, source.pmid, source.arxiv, source.title_author),
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'doi'
);


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.id_map') AS target
USING (
  SELECT *
  FROM identifier('openalex' || :env_suffix || '.works.id_map_candidate_merge_keys')
  WHERE doi IS NULL AND pmid IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY pmid
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON target.pmid = source.pmid
WHEN MATCHED THEN UPDATE SET
  target.merge_key.doi = COALESCE(source.doi, target.merge_key.doi),
  target.merge_key.pmid = COALESCE(source.pmid, target.merge_key.pmid),
  target.merge_key.arxiv = COALESCE(source.arxiv, target.merge_key.arxiv),
  target.merge_key.title_author = COALESCE(source.title_author, target.merge_key.title_author),
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'pmid'
WHEN NOT MATCHED THEN INSERT (
  merge_key, doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  STRUCT(source.doi, source.pmid, source.arxiv, source.title_author),
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'pmid'
);

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.id_map') AS target
USING (
  SELECT *
  FROM identifier('openalex' || :env_suffix || '.works.id_map_candidate_merge_keys')
  WHERE doi IS NULL AND pmid IS NULL AND arxiv IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY arxiv
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON target.arxiv = source.arxiv
WHEN MATCHED THEN UPDATE SET
  target.merge_key.doi = COALESCE(source.doi, target.merge_key.doi),
  target.merge_key.pmid = COALESCE(source.pmid, target.merge_key.pmid),
  target.merge_key.arxiv = COALESCE(source.arxiv, target.merge_key.arxiv),
  target.merge_key.title_author = COALESCE(source.title_author, target.merge_key.title_author),
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'arxiv'
WHEN NOT MATCHED THEN INSERT (
  merge_key, doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  STRUCT(source.doi, source.pmid, source.arxiv, source.title_author),
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'arxiv'
);


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match

-- COMMAND ----------

MERGE INTO identifier('openalex' || :env_suffix || '.works.id_map') AS target
USING (
  SELECT *
  FROM identifier('openalex' || :env_suffix || '.works.id_map_candidate_merge_keys')
  WHERE doi IS NULL AND pmid IS NULL AND arxiv IS NULL AND title_author IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY title_author
    ORDER BY key_score DESC, openalex_updated_dt DESC
  ) = 1
) AS source
ON target.title_author = source.title_author
WHEN MATCHED THEN UPDATE SET
  target.merge_key.doi = COALESCE(source.doi, target.merge_key.doi),
  target.merge_key.pmid = COALESCE(source.pmid, target.merge_key.pmid),
  target.merge_key.arxiv = COALESCE(source.arxiv, target.merge_key.arxiv),
  target.merge_key.title_author = COALESCE(source.title_author, target.merge_key.title_author),
  target.doi = COALESCE(source.doi, target.doi),
  target.pmid = COALESCE(source.pmid, target.pmid),
  target.arxiv = COALESCE(source.arxiv, target.arxiv),
  target.title_author = COALESCE(source.title_author, target.title_author),
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt,
  target.work_id_source = 'title_author'
WHEN NOT MATCHED THEN INSERT (
  merge_key, doi, pmid, arxiv, title_author,
  openalex_created_dt, openalex_updated_dt, work_id_source
) VALUES (
  STRUCT(source.doi, source.pmid, source.arxiv, source.title_author),
  source.doi, source.pmid, source.arxiv, source.title_author,
  source.openalex_created_dt, source.openalex_updated_dt, 'title_author'
);


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Set `id_map.paper_id = [table].paper_id` when matched

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### 'DOI' match using `works_poc.postgres_mid`.

-- COMMAND ----------

-- Merge in legacy paper_id's for DOI
with legacy_doi as (
  SELECT DISTINCT regexp_replace(doi_lower, '[^a-zA-Z0-9.]', '') as doi_lower 
  FROM openalex.works_poc.postgres_mid
  WHERE doi_lower IS NOT NULL
)
, paper_ids as (
  select 
    min(m.paper_id) as paper_id,
    max(m.created_date) as created_dt,
    max(m.updated_date) as updated_dt,
    l.doi_lower
  from legacy_doi l
  inner join openalex.works_poc.postgres_mid m 
    on regexp_replace(
        l.doi_lower,
        '[^a-zA-Z0-9.]',
        ''
      ) = regexp_replace(
        m.doi_lower,
        '[^a-zA-Z0-9.]',
        ''
      ) 
  group by l.doi_lower
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.id_map') AS target
USING paper_ids AS source
  ON LOWER(regexp_replace(target.merge_key.doi, '[^a-zA-Z0-9.]', '')) = LOWER(source.doi_lower)
  AND target.paper_id IS NULL
WHEN MATCHED THEN
UPDATE SET
  target.paper_id = source.paper_id,
  target.openalex_created_dt = source.created_dt,
  target.openalex_updated_dt = source.updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match using `works_poc.postgres_work_extra_ids`.

-- COMMAND ----------

with legacy_pmid AS (
  select
    w.paper_id as paper_id,
    x.attribute_value as pmid
  from openalex.works_poc.postgres_mid w
  inner join openalex.works_poc.postgres_work_extra_ids x
    on w.paper_id = x.paper_id
  where 
  -- (w.doi is null or w.doi = '') 
  --   and
     x.attribute_type = 2 --pmid
)
, paper_ids as (
  select 
    min(m.paper_id) as paper_id,
    max(m.created_date) as created_dt,
    max(m.updated_date) as updated_dt, 
    l.pmid
  from legacy_pmid l
  inner join openalex.works_poc.postgres_mid m 
    on l.paper_id = m.paper_id 
  group by l.pmid
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.id_map') AS target
USING paper_ids AS source
  ON LOWER(TRIM(target.merge_key.pmid)) = LOWER(TRIM(source.pmid))
  AND target.paper_id IS NULL
WHEN MATCHED THEN 
UPDATE SET
  target.paper_id = source.paper_id,
  target.openalex_created_dt = source.created_dt,
  target.openalex_updated_dt = source.updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match using `postgres_work_extra_ids.arxiv_id`

-- COMMAND ----------

WITH legacy_arxiv AS (
  select
    w.paper_id as paper_id,
    w.arxiv_id as arxiv_id
  FROM openalex.works_poc.postgres_mid w
  inner join openalex.works_poc.postgres_work_extra_ids x
    on w.paper_id = x.paper_id 
  where w.arxiv_id is not null 
    -- and (w.doi_lower is null or w.doi_lower = '')
),
paper_ids as (
  select 
    min(m.paper_id) as paper_id,
    max(m.created_date) as created_dt,
    max(m.updated_date) as updated_dt,
    l.arxiv_id
  from legacy_arxiv l
  inner join openalex.works_poc.postgres_mid m 
    on l.paper_id = m.paper_id 
  group by l.arxiv_id
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.id_map') AS target
USING paper_ids AS source
  ON LOWER(TRIM(target.merge_key.arxiv)) = LOWER(TRIM(source.arxiv_id))
  AND target.paper_id IS NULL
WHEN MATCHED THEN
UPDATE SET 
  target.paper_id = source.paper_id,
  target.openalex_created_dt = source.created_dt,
  target.openalex_updated_dt = source.updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match using `postgres_work_extra_ids.unpaywall_normalize_title`

-- COMMAND ----------

WITH legacy_titles AS (
  select
    w.paper_id as paper_id,
    w.unpaywall_normalize_title as unpaywall_normalize_title
  from openalex.works_poc.postgres_mid w
  inner join openalex.works_poc.postgres_work_extra_ids x
    on w.paper_id = x.paper_id 
  where w.arxiv_id is null 
    and w.doi_lower is null 
    and w.unpaywall_normalize_title is not null
)
, paper_ids as (
  select 
    min(m.paper_id) as paper_id,
    max(m.created_date) as created_dt,
    max(m.updated_date) as updated_dt,
    l.unpaywall_normalize_title
  from legacy_titles l
  inner join openalex.works_poc.postgres_mid m 
    on l.paper_id = m.paper_id 
  group by l.unpaywall_normalize_title
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.id_map') AS target
USING paper_ids AS source
  ON LOWER(TRIM(target.merge_key.title_author)) = LOWER(TRIM(source.unpaywall_normalize_title))
  AND target.paper_id IS NULL
WHEN MATCHED THEN 
UPDATE SET 
  target.paper_id = source.paper_id,
  target.openalex_created_dt = source.created_dt,
  target.openalex_updated_dt = source.updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Set `locations_mapped.work_id = id_map.paper_id` when matched

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `DOI` match

-- COMMAND ----------

-- Merge on DOI matches
WITH ids AS (
  SELECT DISTINCT
    merge_key.doi as doi,
    MIN(paper_id) AS paper_id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.id_map')
  WHERE paper_id IS NOT NULL
    AND merge_key.doi IS NOT NULL
  GROUP BY 
    merge_key.doi
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.doi = source.doi
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.paper_id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match

-- COMMAND ----------

 WITH ids AS (
  SELECT DISTINCT
    merge_key.pmid as pmid,
    MIN(paper_id) AS paper_id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.id_map')
  WHERE paper_id IS NOT NULL
    AND merge_key.pmid IS NOT NULL
  GROUP BY
    merge_key.pmid
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.pmid = source.pmid
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.paper_id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match

-- COMMAND ----------

-- Merge on ARXIV matches
WITH ids AS (
  SELECT DISTINCT
    merge_key.arxiv as arxiv,
    MIN(paper_id) AS paper_id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.id_map')
  WHERE paper_id IS NOT NULL
    AND merge_key.arxiv IS NOT NULL
  GROUP BY 
    merge_key.arxiv
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.arxiv = source.arxiv
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.paper_id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match

-- COMMAND ----------

WITH ids AS (
  SELECT DISTINCT
    merge_key.title_author as title_author,
    MIN(paper_id) AS paper_id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.id_map')
  WHERE paper_id IS NOT NULL
    AND (merge_key.doi IS NULL AND merge_key.pmid IS NULL AND merge_key.arxiv IS NULL)
    AND merge_key.title_author IS NOT NULL
  GROUP BY 
    merge_key.title_author
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.title_author = source.title_author
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.paper_id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Populate `locations_mapped.work_id` from `id_map` for work_id is NULL

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `DOI` match

-- COMMAND ----------

WITH ids AS (
  SELECT DISTINCT
    merge_key.doi as doi,
    MIN(id) AS id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.id_map')
  WHERE paper_id IS NULL
    AND merge_key.doi IS NOT NULL
  GROUP BY 
    merge_key.doi
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.doi = source.doi
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `PMID` match

-- COMMAND ----------

-- Merge on PMID matches
WITH ids AS (
  SELECT DISTINCT
    merge_key.pmid as pmid,
    MIN(id) AS id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.id_map')
  WHERE paper_id IS NULL
    AND merge_key.pmid IS NOT NULL
  GROUP BY 
    merge_key.pmid
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.pmid = source.pmid
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `ARXIV` match

-- COMMAND ----------

-- Merge on ARXIV matches
WITH ids AS (
  SELECT DISTINCT
    merge_key.arxiv as arxiv,
    MIN(id) AS id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.id_map')
  WHERE paper_id IS NULL
    AND merge_key.arxiv IS NOT NULL
  GROUP BY 
    merge_key.arxiv
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.arxiv = source.arxiv
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ### `TITLE_AUTHOR` match

-- COMMAND ----------

-- Merge on TITLE_AUTHOR matches
WITH ids AS (
  SELECT DISTINCT
    merge_key.title_author as title_author,
    MIN(id) AS id,
    MAX(openalex_created_dt) AS openalex_created_dt,
    MAX(openalex_updated_dt) AS openalex_updated_dt
  FROM identifier('openalex' || :env_suffix || '.works.id_map')
  WHERE paper_id IS NULL
    AND (merge_key.doi IS NULL AND merge_key.pmid IS NULL AND merge_key.arxiv IS NULL)
    AND merge_key.title_author IS NOT NULL
  GROUP BY 
    merge_key.title_author
)
MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING ids AS source 
  ON target.merge_key.title_author = source.title_author
  AND target.work_id IS NULL
WHEN MATCHED THEN UPDATE SET 
  target.work_id = source.id,
  target.openalex_created_dt = source.openalex_created_dt,
  target.openalex_updated_dt = source.openalex_updated_dt
;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Insert legacy paper_id's based on mag id
-- MAGIC todo: use an UPDATE clause instead of create or replace, still need to test that.

-- COMMAND ----------

WITH mag_walden_works AS (
  SELECT
    get(filter(ids, x -> x.namespace = 'mag').id, 0) AS legacy_work_id,
    MAX(get(filter(ids, x -> x.namespace = 'mag').id, 0)) OVER (
      PARTITION BY work_id
    ) AS assigned_work_id,
    work_id
  FROM identifier('openalex' || :env_suffix || '.works.locations_mapped')
  WHERE provenance = 'mag'
),
updated_mag_walden_works AS (
  SELECT
    work_id AS current_work_id,
    COALESCE(legacy_work_id, assigned_work_id) AS new_work_id
  FROM mag_walden_works
  WHERE COALESCE(legacy_work_id, assigned_work_id) IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY work_id
    ORDER BY COALESCE(legacy_work_id, assigned_work_id)
  ) = 1
)

MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING updated_mag_walden_works AS source
ON target.work_id = source.current_work_id
WHEN MATCHED AND target.work_id > 6600000000 THEN -- only overwrite assigned work ids - not legacy
UPDATE SET
  target.work_id = source.new_work_id;


-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Insert legacy paper_id's based on pmh_id
-- MAGIC todo: use an UPDATE clause instead of create or replace, still need to test that.

-- COMMAND ----------

WITH pmh_mapping AS (
  -- select the lowest work_id (since we have multiple PMH IDs for the same work and a legacy work_id 
  -- is always lower than a newly minted work_id, which increments starting at 6600000001).
  SELECT LOWER(pmh_id) AS pmh_id, MIN(work_id) AS legacy_work_id
  FROM openalex.works_poc.work_id_to_pmh_id_final
  GROUP BY pmh_id
),
repo_walden_works AS (
  SELECT *,
         CASE WHEN provenance IN ('repo', 'repo_backfill') THEN LOWER(native_id) END AS pmh_id_walden
  FROM identifier('openalex' || :env_suffix || '.works.locations_mapped')
  WHERE provenance IN ('repo', 'repo_backfill') AND work_id > 6600000000
),
updated_repo_walden_works AS ( --partition to get MIN legacy_work_id if multiple per work_id exist
  SELECT
    r.work_id AS current_work_id,
    m.legacy_work_id
  FROM repo_walden_works r
  LEFT JOIN pmh_mapping m ON r.pmh_id_walden = m.pmh_id
  WHERE m.legacy_work_id IS NOT NULL
  QUALIFY ROW_NUMBER() OVER (
    PARTITION BY r.work_id
    ORDER BY m.legacy_work_id ASC
  ) = 1
)

MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING updated_repo_walden_works AS source
ON target.work_id = source.current_work_id
WHEN MATCHED THEN UPDATE SET
  target.work_id = source.legacy_work_id;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ## Create `referenced_works` from `references` dois via self-join to get `work_id` values

-- COMMAND ----------

WITH exploded_dois AS (
  SELECT
    work_id,
    EXPLODE(references.doi) AS doi    
  FROM identifier('openalex' || :env_suffix || '.works.locations_mapped')
),
mapped_dois AS (
  SELECT
    ed.work_id AS citing_work_id,
    lm.work_id AS cited_work_id
  FROM exploded_dois ed
  JOIN identifier('openalex' || :env_suffix || '.works.locations_mapped') lm 
    ON LOWER(ed.doi) = LOWER(lm.best_doi)
  WHERE ed.doi IS NOT NULL AND lm.best_doi IS NOT NULL
),
aggregated_refs AS (
  SELECT
    citing_work_id,
    SORT_ARRAY(COLLECT_SET(cited_work_id)) AS referenced_works
  FROM mapped_dois
  GROUP BY citing_work_id
)

MERGE INTO identifier('openalex' || :env_suffix || '.works.locations_mapped') AS target
USING aggregated_refs AS source
ON target.work_id = source.citing_work_id
WHEN MATCHED AND (
  target.referenced_works IS DISTINCT FROM source.referenced_works OR
  target.referenced_works_count IS DISTINCT FROM SIZE(source.referenced_works)
)
THEN UPDATE SET
  target.referenced_works = source.referenced_works,
  target.referenced_works_count = SIZE(source.referenced_works);


-- COMMAND ----------

SELECT format_number(COUNT(*), 0) as row_count
FROM openalex.works.locations_mapped --618,448,502 - July 16th, 618,777,313 - July 17th
